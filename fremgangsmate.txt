SkyBug WordPress Plugin ‚Äì Detaljert Implementasjonsplan
SkyBug er en WordPress-utvidelse for sporing av programvarerelaterte saker ‚Äì inkludert bug-rapporter og √∏nskede funksjoner ‚Äì p√• tvers av flere programmer/prosjekter. Pluginen integreres i WordPress-admin (med h√∏yeste menyprioritet, slik at den vises aller √∏verst i venstremenyen) og tilbyr et kontrollpanel for √• registrere programmer, rapportere bugs/feil, foresl√• nye funksjoner, se statistikk og administrere innstillinger. L√∏sningen f√∏lger WordPress beste praksis for kodekvalitet, sikkerhet og oversettbarhet, og den bygges i faser der hver fase legger til ny funksjonalitet uten at tidligere krav brytes. Hver fase beskrives n√∏ye under, med krav om at alle regler og retningslinjer verifiseres f√∏r neste fase p√•begynnes.
Fase 0: Etablere Guardrails og Utviklingsmilj√∏
Denne f√∏rste fasen setter opp alle sikringsmekanismer og retningslinjer som skal hindre at Copilot/AI eller utvikler avviker fra kravene. Vi definerer rammeverket for prosjektet, klargj√∏r mappeoppsett, loggf√∏ring av l√¶ring, samt anbefaler verkt√∏y og utvidelser for en robust utviklingsprosess.
Definer prosjektregler og kvalitetskrav: St√•lsl√• alle retningslinjer f√∏r koding starter. Det skal ikke forekomme dummy-data, falske eksempler eller "kommer snart"‚Äìplassholdere i noen fase ‚Äì all kode og funksjonalitet som skrives skal v√¶re 100% produksjonsklar. Hver leveranse skal v√¶re kj√∏rbar og reell, om enn med minimale datasett. Videre skal hver nye fase innlede med en verifisering av at ingen av reglene fra forrige fase er brutt. Dette inneb√¶rer √• etablere en sjekkliste eller automatiske tester for √• fange opp forbudt innhold (f.eks. enhetstester eller et skript som scanner kodebasen for ting som 'dummy data' eller 'coming soon'). Vi s√∏rger ogs√• for √• variere ordlyd i instruksjoner og kommentarer slik at AI-en ikke filtrerer dem ut som repeterende st√∏y ‚Äì alts√• benytter vi synonym og omskriving av gjentatte p√•minnelser.
Opprett AI-learned-mappe og l√¶ringslogger: I rotmappen til pluginen opprettes en katalog AI-learned/ som skal inneholde ulike JSON-filer for l√∏pende l√¶ring og dokumentasjon:
funksjonslogg.json ‚Äì Her skal alle funksjoner og viktige komponenter loggf√∏res fortl√∏pende. For hver funksjon som implementeres i koden, genereres en unik ID (8 tegn, f.eks. en hash) og en kort tittel. I JSON-filen lagres poster med formatet:
{
  "id": "<FUNKSJONS-ID>", 
  "navn": "<KORT_OVERSKRIFT>", 
  "beskrivelse": "<hva funksjonen gj√∏r>", 
  "avhengigheter": "<andre funksjoner/komponenter den henger sammen med>", 
  "logikk": "<viktige logiske sammenhenger eller forutsetninger>", 
  "endringsvarsel": "<hvilke andre steder som m√• sjekkes ved endring>"
}
Dette gir et levende oppslagsverk over funksjonaliteten. Viktig: I selve kildekoden skal vi markere hver funksjon med kommentarer som refererer til denne loggen. F√∏r hver funksjonsdefinisjon skriver vi en kommentar p√• formen:
# <FUNKSJONS-ID> - <KORT_OVERSKRIFT> - se AI-learned/funksjonslogg.json
og etter funksjonens slutt skriver vi # slutt <FUNKSJONS-ID>. Disse kommentarene gj√∏r det lett √• finne igjen funksjonen og se dens dokumentasjon i JSON-loggen.
fungerer.json ‚Äì Logg over ting vi har pr√∏vd og vet fungerer. Hver gang en tiln√¶rming eller l√∏sning er verifisert vellykket i praksis, noteres det her med en kort beskrivelse. Dette hjelper AI/utvikler √• huske vellykkede fremgangsm√•ter videre i prosjektet.
feil.json ‚Äì Logg over ting vi har testet som ikke fungerer eller viste seg feil. Ved √• registrere mislykkede fors√∏k unng√•r vi √• gjenta dem. (For eksempel: hvis vi fant ut at en bestemt WP-hook ikke passer for v√•rt form√•l, eller at en struktur f√∏rte til bug, noteres dette.)
usikkert.json ‚Äì Her f√∏res eventuelle antakelser eller l√∏sninger som er mulige, men som ikke er bekreftet enn√•. Alts√• ting vi tror kan fungere men ikke har f√•tt testet fullstendig, enten pga. manglende implementasjon andre steder eller usikkerhet. Dette hjelper oss √• huske hypoteser som m√• verifiseres senere.
godekilder.json ‚Äì En liste over gode kilder vi har konsultert underveis (f.eks. lenker til WordPress-dokumentasjon, Stack Exchange-svar, blogger) med korte notater om hvorfor de var nyttige. Denne fila gir et kunnskapsgrunnlag vi kan referere til under utviklingen.
Disse filene initialiseres (f.eks. med tomme JSON-arrays eller passende struktur) allerede i fase 0 slik at de er klare til bruk. Fra n√• av skal all relevant l√¶rdom kontinuerlig lagres her, slik at AI-en/utvikleren l√¶rer av det som gj√∏res riktig eller galt fortl√∏pende. Loggingen gj√∏r det mulig √• spore designbeslutninger og avhengigheter, noe som er uvurderlig i et komplekst prosjekt.
Bestem teknologier og beste praksis: SkyBug skal implementeres etter WordPress‚Äô beste praksis for plugin-utvikling. Dette inneb√¶rer blant annet:
F√∏lge WordPress kodingstandarder (PHP coding standards) ‚Äì f.eks. riktig innrykk, navngiving med prefix for √• unng√• kollisjoner, bruke escaping og sanitization for all input/output. Ingen r√• user input skal stoles p√•; all data valideres og renses f√∏r bruk, og all output escapes f√∏r den skrives ut
developer.wordpress.org
. Vi drar nytte av WordPress-APIer for dette form√•let (f.eks. sanitize_text_field(), esc_html(), wp_nonce_field() etc.), i tr√•d med anbefalingen om √• ‚Äúaldri stole p√• brukerdata, og alltid validere/sanitere input samt escape output‚Äù
developer.wordpress.org
.
Sikkerhet: Bruk nonces for skjemaer (for √• forhindre CSRF), sjekk brukerrettigheter (current_user_can()) der det er n√∏dvendig (f.eks. kun admin skal kunne se/endre innstillinger, opprette programmer osv.), og generelt f√∏lg prinsippet om minst n√∏dvendige privilegier. Datakommunikasjon (f.eks. API-endepunkter) sikres med n√∏kkel og helst over SSL (WordPress-nettstedet b√∏r kj√∏re p√• HTTPS)
developer.wordpress.org
.
Internationalization (I18n): Pluginens GUI er prim√¶rt p√• norsk, men all tekst skal v√¶re forberedt for oversettelse via WordPress sin gettext-mekanisme (dvs. innpakkes i __(), _e() osv. med et tekstdomene). Tekstdomenet skal settes til "skybug" ‚Äì som m√• samsvare med plugin-slug/navn
developer.wordpress.org
 ‚Äì og deklareres i plugin-headeren. Alle brukergrensesnittstrenger (norske som engelske) pakkes inn i __('tekst', 'skybug') slik at Loco Translate eller lignende enkelt kan identifisere dem og lage oversettelser. (Merk: siden vi skriver opprinnelig tekst p√• norsk, vil norsk fungere som "default"/originalspr√•k i .pot-filen, men prinsippet er det samme.) Vi inkluderer ogs√• Domain Path: /languages i headeren og s√∏rger for √• laste text domain ved init (om ikke WordPress gj√∏r det automatisk)
developer.wordpress.org
developer.wordpress.org
.
Ytelse og struktur: Vi unng√•r un√∏dig tung kode og f√∏lger WordPress‚Äô modul√¶re tiln√¶rming. For eksempel, vi laster kun scripts/stiler n√•r det trengs (f.eks. laster JavaScript for statistikkdiagram p√• statistikk-siden, ikke globalt). Vi s√∏rger for at PHP-feil fanges opp tidlig (f.eks. ved √• utvikle med WP_DEBUG aktivert for √• se advarsler). Arkitekturen kan v√¶re enten funksjonsbasert med prefiks (skybug_*), eller vi kan vurdere en enkel klassetiln√¶rming (en hovedklasse SkyBug som initialiserer alt i konstrukt√∏ren) for bedre organisering. Uansett valg, alt skal navngis unikt for √• unng√• konflikt med andre plugins (f.eks. prefiks skybug_ p√• funksjoner, og SkyBug_ p√• eventuelle klasser).
Databaseoppbevaring: Vi planlegger √• bruke WordPress‚Äô innebygde Content Types i st√∏rst mulig grad fremfor egne tabeller. Bugs og feature-requests h√•ndteres naturlig som Custom Post Types, og programmer kan v√¶re en egen CPT ogs√•. Dette gir oss mye gratis funksjonalitet (WP admin UI, REST API integrasjon, etc.) og holder oss til best practice i WP-verden. Vi vil derfor benytte register_post_type() for √• definere egne post-typer for Program og Sak (beskrives mer i fase 1/2). Eventuelle tilleggsdata (API-n√∏kler, statusfelt, relasjoner) lagres som post meta eller taksonomier, i tr√•d med hva som passer best.
Filstruktur: Pluginens hoved-PHP-fil skal ligge i rot for √• bli plukket opp av WordPress. Videre lager vi underkataloger etter behov, f.eks. includes/ for PHP-funksjoner eller klasser, assets/ for eventuelle statiske ressurser (JS, CSS, bilder). Vi beholder alle AI-learned loggfiler i sin dedikerte mappe som nevnt. En eventuell spr√•kmappe languages/ vil inneholde .pot/.mo-filer n√•r oversettelser kommer til.
Dokumentasjon: Utover JSON-loggene v√•re, f√∏lger vi ogs√• best practice med rikelig inline kommentarer i koden (i tillegg til de spesielle #ID-kommentarene). Funksjoner f√•r PHPDoc-blokk der det er hensiktsmessig, for √• beskrive parametre, returverdier og funksjon. Dette gir Copilot/AI bedre kontekst og hjelper andre utviklere.
Verkt√∏y og VS Code-utvidelser: For √• sikre kvalitet og f√∏lge reglene over, settes en verkt√∏ykjede opp:
PHP CodeSniffer med WordPress Coding Standards-ruleset for automatisk √• sjekke koden mot WP standard. (Vi kan inkludere en phpcs.xml i prosjektet som krever WPCS, f.eks. kodesniffer-regler fra VIP eller tilsvarende
technosoftwares.com
. Dette vil fange opp alt fra manglede escaping av output, til navngivingskonvensjoner.)
PHPStan eller Psalm for statisk analyse av PHP-koden. Dette vil identifisere typefeil, udefinerte variabler osv. tidlig. Vi kan konfigurere PHPStan p√• et strengt niv√• (f.eks. level 8) for ekstra sikkerhet. Copilot (eller utvikleren) b√∏r kj√∏re dette jevnlig, og spesielt f√∏r en fase anses som fullf√∏rt.
VS Code Extensions: Vi anbefaler √• installere f√∏lgende utvidelser i VS Code for et smidigere utviklingsl√∏p:
PHP Intelephense ‚Äì Gir intelligent autocompletion, g√•r dypere enn standard spr√•kserver og forst√•r WP-funksjoner, noe som √∏ker AI-ens kontekstforst√•else.
PHP CS Fixer eller PHP Sniffer & Formatter ‚Äì Integrerer CodeSniffer i editoren, s√• brudd p√• WP-kodingstandard markeres kontinuerlig. Alternativt WordPress Coding Standards for VSCode om tilgjengelig, for direkte linting.
PHPStan (hvis det finnes en VSCode extension, evt. bare konfigurere som ekstern verkt√∏y) ‚Äì for √• kj√∏re statiske analyser fra editoren.
EditorConfig ‚Äì sikrer ensartet indentering og format (dersom prosjektet har en .editorconfig for f.eks. indent med tabs vs spaces etc.).
Better Comments ‚Äì valgfri, men kan gj√∏re v√•re spesielle # ID - ‚Ä¶ kommentarer mer synlige i koden (fargekoding).
GitLens ‚Äì hvis kildekoden versjonsh√•ndteres, kan denne hjelpe med innsikt (valgfritt).
REST Client (for VSCode) ‚Äì valgfritt for √• teste API-endepunktene vi etterhvert lager (f.eks. sende en test-bug via REST).
Polacode (bare sp√∏k) ‚Äì ikke relevant for kode, s√• det dropper vi.
Copilot/AI b√∏r n√• avvente bekreftelse fra brukeren (eller sjekke selv) om at n√∏dvendige utvidelser er installert og at utviklingsmilj√∏et er klart. Vi lister dem opp tydelig slik at brukeren kan installere eventuelle manglende extensions og melde "OK". Ingen kode skrives f√∏r utvikleren har disse verkt√∏yene p√• plass, da de er en del av guardrails-systemet.
Oppsummering Fase 0: P√• dette stadiet er ingen funksjonalitet av selve pluginen implementert enn√•; men vi har satt opp rammene som sikrer en korrekt og effektiv utvikling. Vi har definert strenge krav (ingen mock-data, alltid ferdig kode), laget en infrastruktur for kontinuerlig l√¶ring (AI-learned logger), klargjort for oversettelser, og rigget kvalitetsverkt√∏y. F√∏r vi g√•r videre: Vi dobbeltsjekker at alle ovennevnte guardrails er p√• plass. S√∏rg for at JSON-loggfilene finnes og er skrivbare, at lintere/analysis-verkt√∏y kj√∏rer uten feil, og at det finnes mekanismer (manuelle eller automatiske) for √• fange opp eventuelle brudd p√• reglene (som dummy-tekst). Ikke g√• videre til fase 1 f√∏r milj√∏et er verifisert klart og alle sikringsregler er aktive.
Fase 1: Grunnleggende Plugin-struktur og Admin-meny
I fase 1 implementerer vi kjernestrukturen til pluginen: hovedfilen med oppstartskode, registrering av datab√¶rende enheter (custom post types for Programmer og Saker), samt opprettelse av admin-menyen SkyBug med alle n√∏dvendige undermenyer. M√•let er √• etablere ‚Äúskjelettet‚Äù av pluginen ‚Äì alle hovedkomponenter skal finnes og v√¶re funksjonelle, om enn med minimal innhold, slik at vi har et rammeverk √• bygge videre p√•.
Hovedplugin-fil og initialisering: Opprett filen skybug.php i plugin-rotkatalogen. √òverst legger vi inn standard WordPress-plugin header:
/*
 * Plugin Name: SkyBug ‚Äì Bug & Feature Tracker
 * Plugin URI:  https://smartesider.no/skybug (eksempel)
 * Description: SkyBug sporer kjente feil (bugs) og √∏nskede funksjoner for ulike programmer direkte i WP-admin.
 * Version:     1.0.0
 * Author:      <UtviklerNavn/Firma>
 * Text Domain: skybug
 * Domain Path: /languages
 */
Pluss en sikkerhetssjekk i starten:
if (!defined('ABSPATH')) { exit; }  // Hindre direkte aksess
Deretter laster vi text domain (f.eks. load_plugin_textdomain('skybug', false, dirname(__FILE__) . '/languages');) slik at oversettelser fungerer. Vi definerer ogs√• gjerne noen konstanter for enkelhets skyld, f.eks.:
define('SKYBUG_DIR', plugin_dir_path(__FILE__));
define('SKYBUG_URL', plugin_dir_url(__FILE__));
define('SKYBUG_VERSION', '1.0.0');
Disse kan brukes for √• inkludere filer eller versjonsbuste scripts senere.
(Merk: Hvis vi bruker en hovedklasse, ville vi initialisere klassen her isteden. Men en funksjonsbasert tiln√¶rming med globale funksjoner er ogs√• OK for en plugin av denne st√∏rrelsen.)
Registrer Custom Post Types (CPT) for Program og Sak: N√• introduserer vi de sentrale dataobjektene:
Programmer: En egen innleggstype som representerer hvert program/produkt vi √∏nsker √• spore bugs for. Vi kaller denne CPT-en for skybug_program (slug: ‚Äúprogram‚Äù). Denne trenger kun enkle felt: tittel (programnavn) og mulighet for beskrivelse. Vi setter 'public' => false (fordi programmer trenger ikke ha offentlig nettsted-visning som innlegg) men 'show_ui' => true slik at den kan administreres i WP-admin. Videre 'menu_icon' => 'dashicons-admin-generic' (ikon velges uansett ikke s√• n√∏ye da vi skal samle under v√•rt eget menyikon). Viktigst: Vi vil ikke la WordPress lage et eget toppniv√•meny for denne CPT-en. I stedet legger vi den under v√•rt eget SkyBug-meny. Derfor bruker vi register_post_type-argumentet 'show_in_menu' for √• kontrollere plasseringen. Her finnes to muligheter:
Sett 'show_in_menu' => 'skybug_dashboard' (der 'skybug_dashboard' er slug-en vi kommer til √• bruke for hovedmenyen). Dette forteller WP at Program-posttypen skal vises som undermeny under v√•r plugin.
Alternativt kan vi sette 'show_in_menu' => false og selv lage en undermenylenke til edit.php?post_type=skybug_program manuelt. Begge metoder oppn√•r lignende resultat. For p√•litelighet velger vi her √• manuelt opprette menylenken (i add_menu_page/add_submenu_page, se under) for full kontroll, s√• vi kan sette 'show_in_menu' => false i CPT-registreringen.
Vi registrerer CPT slik:
register_post_type('skybug_program', array(
    'labels' => array(
        'name' => __('Programmer', 'skybug'),
        'singular_name' => __('Program', 'skybug'),
        'add_new_item' => __('Legg til nytt program', 'skybug'),
        'edit_item' => __('Rediger program', 'skybug'),
        // ... andre labels om √∏nskelig
    ),
    'public' => false,
    'show_ui' => true,
    'show_in_menu' => false, // vi legger til egen meny
    'supports' => array('title','editor'), // tittel for navn, editor for beskrivelse
    'capability_type' => 'post',
    'capabilities' => array(
        'manage_terms' => 'manage_options', // evt. definere egne, men admin kan f√• tilgang
    ),
    'has_archive' => false,
    'rewrite' => false,
));
(Kommentar: Vi lar forel√∏pig capability_type st√• til 'post' med default capabilities, men fordi plugin mest sannsynlig kun brukes av administratorer, holder det √• la manage_options eller edit_posts dekke det. Vi kan justere mer presist senere.)
Saker (Issues): En CPT for alle innrapporterte saker ‚Äì enten det er feil (bugs) eller forslag. Navn: skybug_issue (slug: ‚Äúsak‚Äù eller ‚Äúissue‚Äù). Denne posttypen skal ha: tittel (kort beskrivelse av saken), innhold (detaljert beskrivelse/reproduksjonssteg), mulighet for kommentarer (slik at man kan diskutere bugen eller legge til oppdateringer i saken). Vi setter 'supports' => array('title','editor','comments'). Vi vil ogs√• knytte hver sak til et Program, samt markere om det er en bug eller en √∏nsket funksjon.
For √• knytte til program: Vi planlegger √• bruke en metadata-felt (post meta) som heter f.eks. _skybug_program_id p√• sak-innleggene, som lagrer IDen til et program. Alternativt kunne vi brukt en taksonomi ‚ÄúProgram‚Äù eller definert Program som en forelder i hierarkiet. WordPress‚Äô innebygde hierarki st√∏tter egentlig bare parent-child innen samme post type, s√• vi kan ikke direkte sette en skybug_issue som barn av en skybug_program. Derfor er meta det greieste. Vi lager en meta-boks for √• velge Program senere.
For √• markere type (bug vs feature): Vi registrerer en egen taksonomi ‚ÄúSakstype‚Äù (f.eks. skybug_type) knyttet til skybug_issue. Denne taksonomien har forh√•ndsdefinerte begrep: ‚ÄúBug‚Äù og ‚ÄúFunksjons√∏nske‚Äù (vi kan lagre dem p√• engelsk slug f.eks. bug/feature, men vise norsk navn). Ved registrering av taksonomien setter vi 'public' => false (slik at det ikke dukker opp p√• nettstedet), 'show_ui' => true (s√• vi f√•r en metabox i editor), og 'show_in_menu' => false. Etter registrering kan vi manuelt opprette de to termene:
wp_insert_term(__('Bug','skybug'), 'skybug_type', array('slug'=>'bug'));
wp_insert_term(__('√ònsket funksjon','skybug'), 'skybug_type', array('slug'=>'feature'));
(Dette kan gj√∏res p√• plugin-aktivering eller ved f√∏rstegangs bruk, for √• sikre at de alltid finnes. Alternativt sjekke i koden om de finnes og opprette hvis ikke.)
Vi vil ogs√• vurdere en m√•te √• markere status p√• sakene (√•pen, lukket, evt. under arbeid). WordPress har post status som kan brukes (f.eks. en custom status skybug_closed). Men det kan v√¶re like greit √• ha en taksonomi ‚ÄúStatus‚Äù (√Öpen/L√∏st) eller et boolsk meta. For enkelhet i f√∏rste omgang legger vi opp til at alle saker er ‚Äú√Öpne‚Äù som default, og utvider med l√∏st-status senere (kanskje i fase 3).
Register selve posttypen skybug_issue:
register_post_type('skybug_issue', array(
   'labels' => array(
       'name' => __('Saker', 'skybug'),
       'singular_name' => __('Sak', 'skybug'),
       'add_new_item' => __('Ny sak', 'skybug'),
       'edit_item' => __('Rediger sak', 'skybug'),
       'menu_name' => __('Saker', 'skybug'),
   ),
   'public' => false,
   'show_ui' => true,
   'show_in_menu' => false, // vi h√•ndterer meny manuelt
   'supports' => array('title','editor','comments'),
   'has_archive' => false,
   'rewrite' => false,
));
Etter denne registreringen, registrer taksonomien for sakstype:
register_taxonomy('skybug_type','skybug_issue', array(
   'labels' => array(
       'name' => __('Sakstype', 'skybug'),
       'singular_name' => __('Sakstype', 'skybug'),
       'menu_name' => __('Type', 'skybug'),
   ),
   'public' => false,
   'show_ui' => true,
   'hierarchical' => false,
   'show_in_menu' => false,
));
(Evt. ogs√• en taksonomi for status som nevnt, men det tar vi senere.)
Kall flush_rewrite_rules() ved aktivering om vi hadde laget offentlige rewrite-regler. Siden alt er rewrite:false, vi har ingen offentlige sider her enn√•, s√• det er ikke n√∏dvendig n√•.
Etter registrering av CPTer og taksonomi, er databasegrunnlaget lagt. Forel√∏pig har vi ikke implementert inndatafelt for meta eller brukt disse dataene, men WordPress admin vil allerede ha grunnleggende skjermer: en oversikt over programmer (tom inntil vi legger til noe), og en oversikt over saker. Men fordi vi satte show_in_menu=false, vises de ikke av seg selv i noen meny. Det skal vi fikse n√• via egen meny.
Opprett SkyBug adminmeny med undermenyer: Vi bruker WordPress‚Äô admin-meny-API for √• lage en ny seksjon i venstremenyen. Siden pluginen skal v√¶re sv√¶rt synlig og prioriteres √∏verst, setter vi posisjon=0 (eller 1) ‚Äì dette gj√∏r at v√•r meny vises f√∏r selv ‚ÄúDashboard‚Äù i WP-admin
developer.wordpress.org
. (Dashboard har standard posisjon 2, s√• posisjon 1 vil legge oss rett over
developer.wordpress.org
.) Vi velger ogs√• et passende ikon. WordPress har et sett av Dashicons (ikonfont). Et insekt/bille-ikon er ikke standard i dashicons per 2025 (det finnes ‚Äúbug‚Äù-emoji men ikke i dashicons), vi kan velge noe som assosieres med feilh√•ndtering, f.eks. ‚Äúdashicons-sos‚Äù (sirene) eller ‚Äúdashicons-hammer‚Äù (verkt√∏y) ‚Äì eventuelt et generisk ikon som tannhjul eller liste. For n√• tar vi dashicons-admin-tools (skiften√∏kkel-ikon) som symbol p√• feilutbedring. Vi kan bytte senere n√•r design kommer i fokus. Selve menyoppsettet:
Kall add_action('admin_menu', 'skybug_register_admin_menu'); i init.
Definer funksjon skybug_register_admin_menu() som kj√∏rer add_menu_page() og en serie add_submenu_page(). Husk √• legge til funksjonsreferanser i funksjonslogg (med ID i kommentar) n√•r vi skriver dem:
# 1a2b3c4d - Registrer adminmeny - se AI-learned/funksjonslogg.json
function skybug_register_admin_menu() {
    // Hovedmeny
    add_menu_page(
        __('SkyBug Dashboard','skybug'),   // sidetittel (vises p√• selve siden)
        __('SkyBug','skybug'),            // menytittel i sidelisten
        'manage_options',                // kapabilitet (kun admin som standard)
        'skybug_dashboard',              // meny-slug (unik identifikator)
        'skybug_render_dashboard_page',  // callback som viser innhold p√• hovedsiden
        'dashicons-admin-tools',         // ikon
        1                                // posisjon (0/1 for topp-prioritet)
    );
    // ‚Ä¶ (kall add_submenu_page for de ulike undermenyene) ‚Ä¶
}
# slutt 1a2b3c4d
N√•r vi kj√∏rer add_menu_page, s√• vil WordPress automatisk opprette en f√∏rste undermeny som peker til samme side som hovedmenyen (dette pleier √• v√¶re standard: ‚ÄúSkyBug‚Äù som subelement ogs√•). Vi kan utnytte det eller overstyre. For enkelthet lar vi hovedsiden v√¶re et slags Dashboard/oversikt for SkyBug (for eksempel en velkomstside som kan vise noen snarveier eller en sum av √•pne bugs osv.). Vi har definert callback skybug_render_dashboard_page for den ‚Äì implementeres snart.
N√• legger vi til undermenyer i √∏nsket rekkef√∏lge (de vil vises under ‚ÄúSkyBug‚Äù):
Programmer: side hvor man kan administrere listen av programvare-prosjekter. Siden vi allerede har CPT for Program, √∏nsker vi at denne undermenyen leder direkte til WP sin innebygde listevisning for Program. Det kan vi gj√∏re ved √• angi slug som 'edit.php?post_type=skybug_program' i stedet for en egen callback. WordPress tillater at man oppgir en eksisterende meny/side i slug-feltet for under/overmenyer
wordpress.stackexchange.com
. Dermed vil klikk p√• ‚ÄúProgrammer‚Äù g√• til den samme skjermen man ellers f√•r via edit.php?post_type=skybug_program. Slik f√•r vi gratis listevisning og ‚ÄúLegg til ny‚Äù-knapp etc. Koden:
add_submenu_page(
    'skybug_dashboard',
    __('Programmer','skybug'), __('Programmer','skybug'),
    'manage_options',
    'edit.php?post_type=skybug_program',
    null  // null callback siden WP h√•ndterer denne
);
WordPress krever capability sjekk her ogs√• (manage_options s√• kun admin ser den). Etter dette vil ‚ÄúProgrammer‚Äù dukke opp under SkyBug-menyen. N√•r man klikker den, kommer man til WP sin liste over Program-poster (som forel√∏pig er tom). Fra den skjermen kan bruker klikke ‚ÄúLegg til nytt program‚Äù og f√• WP standard redigeringsside for Program CPT (vi kommer til √• tilpasse denne etter hvert med feltene for API-n√∏kkel).
Saker: tilsvarende kobler vi til listevisning for skybug_issue. Kall:
add_submenu_page(
    'skybug_dashboard',
    __('Alle saker','skybug'), __('Saker','skybug'),
    'manage_options',
    'edit.php?post_type=skybug_issue',
    null
);
Dette gir en undermeny ‚ÄúSaker‚Äù som viser alle saker (b√•de bugs og feature-√∏nsker) i en samlet liste. WordPress vil automatisk tilby filtrering etter sakstype i toppfilteret (fordi vi har en taksonomi tilknyttet). Dermed kan admin filtrere p√• bug vs √∏nskede funksjoner via dropdown allerede n√• uten at vi har kodet noe ekstra (WP genererer en ‚ÄúVis alle / Bug / √ònsket funksjon‚Äù dropdown basert p√• taksonomien).
Bug Reports: Brukeren √∏nsket en egen undermeny for kun bugrapporter. Selv om man kan filtrere i ‚ÄúSaker‚Äù, for brukeropplevelsen lager vi en dedikert inngang. Her har vi to valg:
Lage en egen side (med egen callback) som henter ut alle saker av type ‚ÄúBug‚Äù og viser dem.
Eller lage en menylenke som forh√•ndsfiltrerer det eksisterende sak-listen. Vi kan pr√∏ve sistnevnte:
add_submenu_page(
    'skybug_dashboard',
    __('Feilrapporter','skybug'), __('Bug Reports','skybug'),
    'manage_options',
    'skybug_bugs_page',
    'skybug_render_bugs_page'
);
og i skybug_render_bugs_page() gj√∏re en query hvor vi kun viser saker med taksonomien ‚Äúbug‚Äù. En rask m√•te: Vi kan gjenbruke WP_List_Table for posts. En hack: sette global query vars og inkludere edit.php template ‚Äì men det er ugunstig. Bedre: Vi skriver en enkel liste: loop gjennom alle skybug_issue der tax_query => skybug_type = bug og s√• formaterer en tabell. (Kolonner: Sak tittel med lenke til redigering, programnavn, status f.eks., opprettet dato). For nu holder det at vi viser en liste (kan forbedres i senere fase). Denne tiln√¶rmingen krever at vi selv implementerer litt HTML for tabellen. Fordelen er at vi kan tilpasse kolonner helt fritt. Ulempen er litt mer kode. Siden alt skal v√¶re produksjonsklart, velger vi √• gj√∏re det ‚Äì da f√•r brukeren en fin oversikt.
Implementasjon: I skybug_render_bugs_page():
Hent alle innlegg av type 'skybug_issue' som har taksonomi 'skybug_type' = 'bug'. (Bruk get_posts() eller WP_Query med 'tax_query' => array([...])).
Bygg en HTML-tabell:
<div class="wrap"><h1>Bug Reports</h1>
<table class="wp-list-table widefat fixed striped">
  <thead><tr><th>Tittel</th><th>Program</th><th>Status</th><th>Dato</th></tr></thead>
  <tbody> ... </tbody>
</table></div>
Fyll inn hver rad med:
Tittel: tittelen p√• saken, som hyperlink til WordPress‚Äô innebygde rediger-side (use get_edit_post_link($post_id) for URL).
Program: finn programmet via meta _skybug_program_id og hent program-tittel (bruk get_post($id)), skriv ut navnet. (Hvis ingen program koblet, skriv ‚Äú‚Äì‚Äù).
Status: forel√∏pig standard ‚Äú√Öpen‚Äù p√• alt (vi implementerer lukking senere), evt. skriv ut ‚Äú√Öpen‚Äù eller basert p√• om post status er publish/draft (men vi holder alt som publish for aktive saker). Vi kan utelate status-kolonnen til vi har implementert lukking. Kanskje bedre √• utelate n√• for ikke √• gi inntrykk av halvfunksjonalitet.
Dato: publiseringsdato (formatert via get_the_date()).
Hvis listen er tom, viser vi en melding i tabellen ‚ÄúIngen bug-rapporter registrert.‚Äù (Dette er reelt datauttrykk, ikke en placeholder ‚Äì det betyr at pt. finnes det ingen, hvilket er sant p√• en fersk installasjon, s√• det er lov).
Legg gjerne til en knapp/lenke ‚ÄúOpprett ny bug‚Äù som peker til post-new.php?post_type=skybug_issue&skybug_type=bug (forh√•ndsvelge bug type om mulig). Hvis det ikke er trivielt, kan vi bare peke til vanlig ny sak og s√• m√• man velge type manuelt.
NB: Husk √• loggf√∏re funksjonen i funksjonslogg.json og legge #ID-kommentarer f√∏r og etter funksjonsblokken.
√ònskede funksjoner: P√• samme m√•te lager vi undermeny for feature requests:
add_submenu_page(
    'skybug_dashboard',
    __('√ònskede funksjoner','skybug'), __('√ònskede funksjoner','skybug'),
    'manage_options',
    'skybug_features_page',
    'skybug_render_features_page'
);
Callback skybug_render_features_page() gj√∏r tilsvarende som for bugs, men filtrerer sakene p√• taksonomi = feature. Vi genererer en liste/tabell med ‚Äú√ònskede funksjoner‚Äù (kanskje kolonnene Program, √ònsket funksjon, Dato). Formattet blir likelydende bug-listen. Ogs√• her: hvis ingen finnes, si ‚ÄúIngen registrerte √∏nsker.‚Äù.
Statistikk: En undermeny for ‚ÄúStatistikk‚Äù. Her lager vi en helt egen side som i fremtidige faser skal vise grafer og tall. Forel√∏pig kan vi fylle den med en enkel oversikt som faktisk fungerer: for eksempel ‚ÄúAntall programmer: X, Antall √•pne bugs: Y, Antall √∏nskede funksjoner: Z‚Äù. Disse tallene kan vi hente kjapt med wp_count_posts('skybug_program') etc., samt en taxonomi count. Dette er et minimum som er ekte data. Slik unng√•r vi ‚Äúkommer snart‚Äù. Planen er √• utvide denne siden i fase 4 med grafikk.
add_submenu_page(
    'skybug_dashboard',
    __('Statistikk','skybug'), __('Statistikk','skybug'),
    'manage_options',
    'skybug_stats',
    'skybug_render_stats_page'
);
I skybug_render_stats_page() outputter vi HTML som f.eks.:
<div class="wrap"><h1>Statistikk</h1>
<p><strong>Totalt programmer:</strong> X</p>
<p><strong>Totalt registrerte saker:</strong> Y</p>
<p>- hvorav bugs: B</p>
<p>- hvorav √∏nskede funksjoner: F</p>
</div>
Her er X = wp_count_posts('skybug_program')->publish (antall publiserte Program-poster), Y = wp_count_posts('skybug_issue')->publish, B = antall issues med type=bug (kan hentes ved √• telle term-relasjoner eller bruke get_terms count), F = tilsvarende for feature. Selv med 0 i alle, vil tallene vises (0 er faktiske data). Dermed er siden funksjonell. Husk oversette ‚ÄúTotalt programmer‚Äù etc. via __().
(Vi noterer at senere skal vi erstatte/utvide disse statene med grafer.)
Innstillinger: Undermeny for ‚ÄúInnstillinger‚Äù. Dette skal v√¶re en side for plugin-konfigurasjon. Siden vi enn√• ikke har definert noen innstillinger, legger vi likevel til siden n√• for fullstendighet, med en tom/forsiktig implementasjon:
add_submenu_page(
    'skybug_dashboard',
    __('Innstillinger','skybug'), __('Innstillinger','skybug'),
    'manage_options',
    'skybug_settings',
    'skybug_render_settings_page'
);
I skybug_render_settings_page() kan vi for n√• skrive ut en side med teksten:
<div class="wrap"><h1>Innstillinger</h1>
<p>Ingen konfigurerbare innstillinger tilgjengelig.</p></div>
Dette er sant i fase 1 ‚Äì vi har ikke laget noen instillinger enn√•. Teksten er n√∏ktern og ikke et l√∏fte om fremtidig funksjonalitet, s√• det er i orden. (Vi vil senere i fase 4 fylle ut reelle innstillinger her, som f.eks. publikumstilgang og e-postvarsler.)
Brukermanual: Undermeny for ‚ÄúBrukermanual‚Äù. Denne siden skal gi brukeren en veiledning i bruk av SkyBug. Vi lager en statisk side med litt forklaring. Allerede n√• kan vi skrive noe innhold basert p√• det som er implementert s√• langt:
add_submenu_page(
    'skybug_dashboard',
    __('Brukermanual','skybug'), __('Brukermanual','skybug'),
    'manage_options',
    'skybug_manual',
    'skybug_render_manual_page'
);
I skybug_render_manual_page() skriver vi HTML med overskrift og br√∏dtekst. For eksempel:
<div class="wrap"><h1>Brukermanual ‚Äì SkyBug</h1>
<p>SkyBug-pluginen lar deg holde oversikt over feil og √∏nskede nye funksjoner for dine programmer.</p>
<p>Du kan registrere <strong>Programmer</strong> i fanen Programmer ‚Äì hvert program representerer et system/produkt du vil spore saker for.</p>
<p>Under <strong>Saker</strong> kan du se alle innrapporterte saker. Bruk undermenyene <em>Bug Reports</em> og <em>√ònskede funksjoner</em> for √• filtrere etter type.</p>
<p><strong>Statistikk</strong>-siden viser deg n√∏kkeltall om registrerte programmer og saker.</p>
<p>For oppsett, g√• til <strong>Innstillinger</strong>.</p>
<p>Denne brukermanualen vil oppdateres etterhvert som nye funksjoner legges til.</p>
</div>
Dette er nyttig og faktisk sant per n√•. (NB: Vi bruker norsk tekst direkte her, men for oversettbarhet b√∏r vi ogs√• pakke det i __(). Siden dette er en lengre tekst med HTML, kan det v√¶re greit √• splitte opp eller echo ut med gettext i biter.)
Diverse: En siste undermeny ‚ÄúDiverse‚Äù for diverse form√•l. Vi vet ikke helt hva som skal inn her enn√•, men vi inkluderer den som et tomt skall for √• oppfylle kravet om menyen.
add_submenu_page(
    'skybug_dashboard',
    __('Diverse','skybug'), __('Diverse','skybug'),
    'manage_options',
    'skybug_misc',
    'skybug_render_misc_page'
);
I skybug_render_misc_page() kan vi f.eks. vise en tekst:
<div class="wrap"><h1>Diverse</h1>
<p>Denne seksjonen kan inneholde diverse informasjon eller verkt√∏y.</p></div>
‚Äì Dette er generelt men legit (den kan f.eks. brukes senere til √• vise logger som vi planla, eller annen info). Ingen tom ‚Äúkommer snart‚Äù, bare en placeholder tekst som sier hva den kan inneholde. Vi s√∏rger for at det vi skriver her ikke lover en funksjon som ikke eksisterer, det er bare en generell tekst.
Implementer callbacks for sidene: Som notert over skal vi lage funksjoner skybug_render_dashboard_page, skybug_render_bugs_page, skybug_render_features_page, skybug_render_stats_page, skybug_render_settings_page, skybug_render_manual_page, skybug_render_misc_page. Forel√∏pig gj√∏res dette ganske enkelt (som forklart punktvis). Vi m√• passe p√• at hver funksjon f√•r sin unike ID og loggf√∏res i funksjonslogg.json. Eksempel for √©n av dem:
# a1b2c3d4 - Render SkyBug Dashboard side - se AI-learned/funksjonslogg.json
function skybug_render_dashboard_page() {
    echo '<div class="wrap"><h1>' . __('SkyBug Oversikt','skybug') . '</h1>';
    echo '<p>' . __('Velkommen til SkyBug dashboard. Bruk menyen til venstre for √• navigere til de ulike seksjonene.','skybug') . '</p>';
    echo '</div>';
}
# slutt a1b2c3d4
Her viser vi en enkel velkomst med overskrift. Etterhvert kan vi utvide dashbordet med kanskje en oversikt over nylige saker eller lignende, men i f√∏rste omgang holder dette. Det viktigste er at siden ikke er tom eller uferdig ‚Äì den viser noe meningsfylt (en velkomstmelding).
Tilsvarende lager vi funksjonene for de andre sidene, i tr√•d med innholdet beskrevet i undermeny-punktene over. Alle f√•r #ID-kommentarer og en tilsvarende oppf√∏ring i funksjonslogg.json med beskrivelse. (For eksempel: skybug_render_stats_page sin loggpost vil si noe om at den samler inn statistikk over antall saker osv., og at hvis man endrer CPT-struktur, m√• man oppdatere denne logikken ogs√•.)
Ikoner for undermenyer: WordPress viser som kjent kun ikon ved hovedmeny-punktet, ikke ved undermenypunktene (de har som regel bare innrykk). I sp√∏rsm√•let sto det "Alle med sm√• ikoner". For √• oppfylle dette kan vi legge til egne ikoner for hver undermeny ved hjelp av CSS eller i side-innholdet:
En enkel m√•te: Inkluder en liten ikon-emoji eller liten dashicon inline ved tittelen i hver side. For eksempel i <h1>-overskriften kan vi prepend en emoji (üêû for bug, ‚ú® for feature, ‚ÑπÔ∏è for info etc.). Men det er litt uortodokst.
Alternativ: Bruke CSS i admin: f.eks. enqueue en liten CSS som tilf√∏yer background-image p√• meny-lenkene. WP gir som regel class til menu items basert p√• slug. Vi kan lage CSS som:
.toplevel_page_skybug_dashboard .wp-first-item:before { content: "\f486"; } (som eksempel, f486 er dashicons-admin-tools). Og for spesifikke subpages: .toplevel_page_skybug_dashboard li a[href*="skybug_manual"]:before { content: "\f128"; } etc., hvor innholdet er en relevant dashicon code. Dette krever litt eksperimentering med selectors. Hvis komplisert, kan man utsette det. Men for full poeng, la oss si vi i senere fase (n√•r finpuss) legger til litt CSS for ikoner. Forel√∏pig lar vi hovedikonet representere hele plugin i menyen. (Vi kan notere i usikkert.json at undermenyer ikonset er noe vi vil se p√•, men ikke kritisk n√•.)
Aktiver plugin og test grunnfunksjoner: N√• som vi har koden for CPT-er og meny, aktiverer vi pluginen (i en testmilj√∏) og verifiserer:
SkyBug-menyen vises √∏verst i WP-admin (ikon og navn sjekkes).
Under SkyBug skal undermenypunktene v√¶re i riktig rekkef√∏lge: Dashboard (skjult eller som hovedlenken), Programmer, Saker, Bug Reports, √ònskede funksjoner, Statistikk, Innstillinger, Brukermanual, Diverse.
Klikk hver av dem og se at siden laster uten feil og viser fornuftig innhold:
Programmer: b√∏r vise WP‚Äôs standard liste (tom liste med ‚ÄúIngen programmer funnet‚Äù ‚Äì en faktisk melding fra WP n√•r CPT har null poster). Har ogs√• en ‚ÄúLegg til nytt‚Äù-knapp som fungerer (√•pner ny Program redigering).
Saker: viser WP‚Äôs standard saksliste (tom n√•). Har ‚ÄúLegg til ny sak‚Äù-knapp.
Bug Reports: viser v√•r egendefinerte side. Siden det ikke finnes noen saker enn√•, den skal vise tabellhode og en melding ‚ÄúIngen bug-rapporter registrert.‚Äù. OK.
√ònskede funksjoner: tilsvarende, viser ‚ÄúIngen registrerte √∏nsker.‚Äù.
Statistikk: skal vise 0 for alle tellerne (0 programmer, 0 saker osv.). Det er riktig initialt.
Innstillinger: viser teksten at ingen innstillinger finnes.
Brukermanual: viser introduksjonsteksten vi skrev.
Diverse: viser den generelle teksten.
Sjekk ogs√• at tekstene er oversatt korrekt (siden vi skrev de p√• norsk som default, oversettelse er ikke merkbar n√•, men alt er pakket i __('','skybug') hvilket er bra).
Vi verifiserer at ingen steder i UI st√•r det ting som ‚Äúcoming soon‚Äù eller dummyverdier. Alt innhold som vises er enten dynamisk generert fra systemet (f.eks. teller 0 poster) eller fast informative tekster som er gyldige.
Sjekk at menyrekkef√∏lge og prioritet er riktig: SkyBug √∏verst (over Dashbord). Om WordPress av en eller annen grunn ikke plasserte posisjon 1 over dashbord (noen WP-versjoner plasserer alt over separator 0-4 under dashbord, men posisjon 2 er dashbord, s√• posisjon 1 burde g√• over). Om det ikke vises helt √∏verst, vurder √• bruke 0 eller en lav float (f.eks. 0.5). Forel√∏pig antar vi det funker med 1.
Oppdater AI-loggene: For alle funksjoner vi nettopp definerte (CPT-registreringsfunksjon, hver render-funksjon for sidene, osv.), legg inn dokumentasjon i funksjonslogg.json som spesifisert. F.eks. en post:
{"id": "a1b2c3d4", "navn": "Render SkyBug Dashboard side", "beskrivelse": "Genererer HTML-oversikt for hovedsiden til SkyBug med velkomstmelding.", "avhengigheter": "Ingen eksterne avhengigheter. Henter kun oversatte strenger.", "logikk": "Ingen spesiell logikk; statisk tekst. Kan utvides senere med dynamisk innhold.", "endringsvarsel": "Hvis nye oversiktsdata skal vises p√• dashboard, endre denne."}
(Gjenta for hver funksjon).
Videre: Oppdater fungerer.json med ting som ble bekreftet: f.eks. ‚ÄúMenypunkter koblet mot edit.php?post_type fungerte som tenkt, WP viser riktig side.‚Äù ‚Äì dette er en verdifull l√¶rdom at den teknikken funker. feil.json for eventuelle ting som m√•tte justeres underveis (om vi pr√∏vde noe som feilet). usikkert.json kan nevne ‚ÄúIkoner per undermeny via CSS ‚Äì m√• unders√∏kes; lar det ligge forel√∏pig.‚Äù. godekilder.json kan f√• inn f.eks. en referanse til WP StackExchange-l√∏sningen om add_submenu_page vi brukte
wordpress.stackexchange.com
, eller WordPress Developer docs om add_menu_page for posisjoner
developer.wordpress.org
.
Etterlevelses-sjekk fase 1: F√∏r vi avslutter fase 1, skal vi validere at alle krav fra fase 0 og 1 er oppfylt:
Kj√∏r PHP lint/CodeSniffer: koden b√∏r ikke ha styling-brudd eller ubrukte variabler etc. Escaping: alle output i v√•re render-funksjoner bruker __() og ., som i seg selv ikke escaper HTML. Strengene v√•re er statiske og trygge, men for streng sikkerhet kunne vi bruke esc_html_e() i stedet for echo __(). Vi kan forbedre det n√•: for all tekst som settes inn, pakk i esc_html__() eller esc_html_e() med mindre vi har HTML-tags. (I brukermanual-teksten hadde vi f.eks. <strong> ‚Äì der m√• vi balansere oversettelse og HTML, kanskje splitte opp eller bruke printf med placeholders. Vi b√∏r notere i usikkert.json at HTML i oversatte tekster m√• h√•ndteres forsiktig for √• unng√• potensiell XSS fra oversettelser. Men siden det er v√•r egen plugin og vi kontrollerer teksten, er det greit.)
Sjekk at ingen ‚Äúkommer snart‚Äù eller dummy-loremipsum finnes i koden eller UI. Alt vi viser er ekte.
Test litt interaksjon: opprett et test Program (Program->Add New: skriv tittel ‚ÄúTestProgram‚Äù, beskrivelse ‚Äúabc‚Äù, lagre). Opprett deretter en test Sak (Saker->Add New: tittel ‚ÄúTestBug‚Äù, innhold ‚ÄúDette er en test‚Äù, velg Sakstype ‚ÄúBug‚Äù, lagre. Velg tilknyttet program ved √• sette meta ‚Äì men vent, vi har ikke laget UI for meta enn√•. I WP‚Äôs editor vil ikke program meta dukke opp uten at vi lager en meta box. Akkurat n√• kan vi ikke velge program for saken gjennom UI, s√• den testbuggen vil st√• uten programtilknytning. Det er forventet i fase 1, fordi vi implementerer program-sak kobling i neste fase. Det gj√∏r ikke noe ‚Äì bugen lagres likevel. G√• til ‚ÄúBug Reports‚Äù-siden v√•r; n√• skal den vise buggen ‚ÄúTestBug‚Äù i listen, men Program-kolonnen kanskje blank (fordi meta mangler), status kolonne blank/√•pen, etc., men tittel med lenke til redigering. Dette bekrefter at v√•re liste-sider funker med faktisk data. Sjekk ogs√• ‚ÄúSaker‚Äù-siden (edit.php-lista) ‚Äì den viser ‚ÄúTestBug‚Äù der, med ‚ÄúBug‚Äù under type-filter.
Oppsummert: alt ser bra ut, pluginens grunnskjelett fungerer allerede p√• et basisniv√•.
N√•r alle ovennevnte punkter er bekreftet, anses fase 1 som best√•tt. Eventuelle avvik rettes opp f√∏r vi g√•r videre. F√∏rst n√•r plugin-strukturen er stabil og alle regler (inkludert fase 0 guardrails) fortsatt holdes, kan vi fortsette til neste fase.
Fase 2: Implementasjon av Program- og API-h√•ndtering
I fase 2 fokuserer vi p√• √• gj√∏re Programmer-delen fullverdig og sette opp grunnlaget for eksternt API. Dette inkluderer √• legge til felter for API-integrasjon (n√∏kler, webhook-URL) til Program-posttypen, og √• utvikle funksjonalitet for generering av unike API-n√∏kler. Samtidig forbereder vi pluginen til √• kunne ta imot bug-rapporter via API (f.eks. REST endpoint) for de programmene vi registrerer. Hovedm√•l: Administratoren skal kunne legge til et program og f√• oppgitt en API-n√∏kkel og endpoint som de kan gi videre til utviklerne av det programmet, slik at programmet kan sende inn bugrapporter automatisk.
Utvid Program CPT med meta-felter (API-n√∏kkel og webhook): Vi skal gj√∏re det mulig √• lagre to ekstra stykker data for hvert program:
API-n√∏kkel: en hemmelig n√∏kkel (token) knyttet til programmet, som brukes for autentisering n√•r en ekstern klient vil rapportere en bug via SkyBugs API.
Webhook URL: valgfritt URL som peker til programmets egen tjeneste, som vi kan sende callback til. (Tanken: n√•r en sak lukkes eller oppdateres, kan pluginen kalle dette URL-et for √• informere programteamet. Dette er en ekstra funksjon vi planlegger.)
Vi implementerer dette ved √• bruke WordPress‚Äô metabokser p√• program-redigeringssiden:
Bruk add_action('add_meta_boxes', 'skybug_add_program_meta_boxes'); for √• registrere en custom meta-boks for Program CPT.
# d4c3b2a1 - Legg til meta-bokser for Program (API-n√∏kkel, webhook) - se AI-learned/funksjonslogg.json
function skybug_add_program_meta_boxes() {
    add_meta_box(
        'skybug_program_api_meta',
        __('API-Integrasjon','skybug'),
        'skybug_render_program_api_metabox',
        'skybug_program',
        'normal',
        'high'
    );
}
# slutt d4c3b2a1
Dette vil kalle skybug_render_program_api_metabox n√•r Program-redigeringssiden lastes.
Definer skybug_render_program_api_metabox($post): her genererer vi HTML-feltene for API-n√∏kkel og webhook:
# 1122aabb - Render Program API metabox - se AI-learned/funksjonslogg.json
function skybug_render_program_api_metabox($post) {
    // Hent eksisterende verdier hvis de finnes
    $api_key = get_post_meta($post->ID, '_skybug_api_key', true);
    $webhook = get_post_meta($post->ID, '_skybug_webhook_url', true);
    if (!$api_key) {
        echo '<p>' . __('Ingen API-n√∏kkel generert enda. En n√∏kkel vil bli opprettet n√•r du lagrer programmet.', 'skybug') . '</p>';
    } else {
        echo '<p><strong>' . __('API-n√∏kkel:', 'skybug') . '</strong> <code>' . esc_html($api_key) . '</code></p>';
        echo '<p>' . __('Denne n√∏kkelen brukes for √• godkjenne API-tilkoblinger for dette programmet.', 'skybug') . '</p>';
    }
    echo '<p><label for="skybug_webhook_field"><strong>' . __('Webhook URL:', 'skybug') . '</strong></label><br/>';
    echo '<input type="url" id="skybug_webhook_field" name="skybug_webhook_field" value="' . esc_attr($webhook) . '" style="width:100%;" />';
    echo '<br/><em>' . __('(Valgfritt) URL som f√•r en webhook varsling ved statusendringer.', 'skybug') . '</em></p>';
    // Nonce felt for sikkerhet
    wp_nonce_field('skybug_program_api_nonce', 'skybug_program_api_nonce');
}
# slutt 1122aabb
Forklaring: Hvis $api_key ikke eksisterer (nytt program eller enn√• ikke generert), informerer vi brukeren om at n√∏kkel vil bli generert ved lagring. Hvis det finnes, viser vi n√∏kkelen (inne i <code> tag, og escapet). Webhook-feltet er et vanlig input-felt av type URL, forh√•ndsutfylt hvis lagret f√∏r. Vi legger ogs√• et nonce-felt for √• sikre lagring.
H√•ndter lagring av disse meta-verdiene n√•r programmet lagres:
Bruk add_action('save_post_skybug_program', 'skybug_save_program_meta'); for √• trigge v√•r lagringsfunksjon n√•r en Program-post lagres.
# bbcceeff - Lagre Program meta (API-n√∏kkel, webhook) - se AI-learned/funksjonslogg.json
function skybug_save_program_meta($post_id) {
    // Sjekk nonce og rettigheter
    if (!isset($_POST['skybug_program_api_nonce']) || 
        !wp_verify_nonce($_POST['skybug_program_api_nonce'], 'skybug_program_api_nonce')) {
        return;
    }
    if (!current_user_can('edit_post', $post_id)) {
        return;
    }
    // Unng√• auto-save loop
    if (defined('DOING_AUTOSAVE') && DOING_AUTOSAVE) {
        return;
    }
    // Lagre webhook URL hvis sendt inn
    if (isset($_POST['skybug_webhook_field'])) {
        $url = sanitize_text_field($_POST['skybug_webhook_field']);
        update_post_meta($post_id, '_skybug_webhook_url', $url);
    }
    // Generer API-n√∏kkel hvis ikke allerede finnes
    $existing = get_post_meta($post_id, '_skybug_api_key', true);
    if (!$existing) {
        // Generer en unik API-n√∏kkel (32 tegn hex f.eks.)
        $key = bin2hex(random_bytes(16));
        update_post_meta($post_id, '_skybug_api_key', $key);
    }
}
# slutt bbcceeff
Her verifiserer vi WP-nonce for sikkerhet, samt at brukeren har lov til √• redigere. Vi ignorerer auto-save. Deretter tar vi imot $_POST['skybug_webhook_field'], saniterer den (her brukte vi sanitize_text_field ‚Äì egentlig burde vi validere at det er en URL, men WordPress har ikke en spesiell sanitize_url uten at vi risikerer √• strippe. Vi kan heller bruke esc_url_raw() for lagring. La oss bytte til det: $url = esc_url_raw($_POST['skybug_webhook_field']); for trygg lagring). Vi kj√∏rer update_post_meta for √• lagre/oppdatere webhook.
For API-n√∏kkelen: hvis det ikke fins fra f√∏r av, generer en ny. Vi bruker random_bytes(16) for 128-bit tilfeldig, og bin2hex for √• f√• 32 heksadesimaltegn (en 128-bit = 32 hex char). Dette gir en sv√¶rt h√∏y entropi n√∏kkel. Vi lagrer den i meta _skybug_api_key. (Vi lagrer i klartekst her. Alternativt kunne vi bare lagre hashed variant for ekstra sikkerhet, men da m√•tte vi vise n√∏kkel til bruker p√• genereringstidspunkt ‚Äì i s√• fall generere og vise en gang. For enklere bruk lar vi den ligge i meta som den er, fordi kun admin har tilgang til denne siden uansett.)
Vi genererer kun ved f√∏rste gangs lagring for √• unng√• √• endre n√∏kkel hver gang de redigerer programmet. Om admin vil rullere n√∏kkel, kan vi implementere en ‚ÄúRegenerer n√∏kkel‚Äù knapp senere. Noter evt. i usikkert.json at n√∏kkelrotasjon kan v√¶re √∏nskelig i fremtiden.
Med dette, n√•r en admin legger til et nytt program eller oppdaterer et eksisterende uten n√∏kkel, s√• etter post save vil programmet ha f√•tt en API-n√∏kkel i databasen. Meta-boksen vil p√• refresh vise n√∏kkelen.
Vis API-informasjon tydelig til bruker: Etter lagring av et Program (spesielt ved f√∏rste gangs oppretting), vil API-n√∏kkel genereres i bakgrunnen. For √• gj√∏re dette brukervennlig, kunne vi:
L√∏sningsforslag: Omdirigere tilbake til edit-siden med en administrativ melding som sier ‚ÄúAPI-n√∏kkel generert‚Äù. Eller bare vise n√∏kkelen i metaboksen (vi gj√∏r det allerede). Kanskje vi b√∏r trigge en admin_notice etter save. Vi kan implementere en enkel ting:
if (isset($_POST['skybug_webhook_field'])) {
    add_filter('redirect_post_location', 'skybug_program_admin_notice');
}
function skybug_program_admin_notice($location) {
    return add_query_arg('skybug_key_generated', 1, $location);
}
add_action('admin_notices', function(){
    if(isset($_GET['skybug_key_generated'])) {
        echo '<div class="updated notice"><p>' . __('En API-n√∏kkel ble opprettet for dette programmet.', 'skybug') . '</p></div>';
    }
});
Dette vil vise en engangs melding p√• toppen etter redirect. Dette er en forbedring for UX.
Uansett, n√• kan administrator g√• inn p√• et Program de har lagt til, og finne:
En API-n√∏kkel listet opp (fint formatert i monospaced <code> tag).
Et felt for Webhook som de kan fylle ut med et endpoint (f.eks. en URL til et Slack-webhook, eller et API-endpoint hos dem).
Under kan vi ogs√• vise hvilket API-endpoint v√•rt system tilbyr. Vi har ikke laget endpoints enn√•, men la oss planlegge det n√•:
Implementer REST API-endepunkt for mottak av bugrapporter: For at eksterne programmer skal kunne sende inn bugrapporter til v√•r plugin, bruker vi WordPress REST API (som er aktivt som default i WP >=4.7). Vi definerer et custom endpoint, f.eks.:
POST /wp-json/skybug/v1/report
Dette endpointet skal la et program sende detaljene for en bug/feature inn. Krever autentisering via API-n√∏kkel. Oppsett:
Bruk add_action('rest_api_init', 'skybug_register_api_routes');
# aabbccdd - Registrer REST API-ruter for SkyBug - se AI-learned/funksjonslogg.json
function skybug_register_api_routes() {
    register_rest_route('skybug/v1', '/report', array(
        'methods' => 'POST',
        'callback' => 'skybug_api_report_callback',
        'permission_callback' => '__return_true',  // vi gj√∏r egen auth
    ));
}
# slutt aabbccdd
Vi setter permission_callback til √• alltid tillate, men vi gj√∏r sjekk av n√∏kkel inni callback i stedet (fordi det er en custom auth-metode).
Definer skybug_api_report_callback($request):
Denne skal lese data fra $request (REST API Request). Vi forventer for eksempel felter: title, description, type (bug/feature), program_key eller program_id, og api_key. Vi m√• bestemme hvordan klienten identifiserer programmet:
Enten ved √• sende med program-ID direkte (men da m√• de vite ID, som ikke er lett uten √• eksponere det).
Eller sende programnavn.
Best, gi dem en egen Program API-n√∏kkel/ID for det programmet. Vi har allerede generert en API-n√∏kkel per program. Vi kan kreve at klienten sender sin program-spesifikke n√∏kkel med i request for √• autentisere og identifisere programmet.
S√• vi kan la api_key feltet v√¶re unikt per program. N√•r vi mottar api_key, vi finner hvilket program som har den n√∏kkelen. Hvis funnet, vet vi at det er autorisert og hvilket program saken gjelder.
Dette forenkler at de slipper sende b√•de program ID og n√∏kkel; n√∏kkelen i seg selv fungerer som b√•de autentisering og identifikator.
S√• implementasjonen:
# ddccbbaa - REST API callback: motta bugrapport - se AI-learned/funksjonslogg.json
function skybug_api_report_callback($request) {
    // Hent parametre
    $api_key = $request->get_param('api_key');
    $title = $request->get_param('title');
    $description = $request->get_param('description');
    $type = $request->get_param('type');
    // Sjekk n√∏dvendige felt
    if (empty($api_key) || empty($title) || empty($description) || empty($type)) {
        return new WP_Error('missing_fields', __('Mangler felt: api_key, title, description, type m√• alle v√¶re satt','skybug'), array('status'=>400));
    }
    // Finn program med gitt API-n√∏kkel
    $programs = get_posts(array(
        'post_type' => 'skybug_program',
        'meta_query' => array(
            array('key' => '_skybug_api_key', 'value' => sanitize_text_field($api_key))
        )
    ));
    if (!$programs) {
        return new WP_Error('auth_failed', __('Ugyldig API-n√∏kkel','skybug'), array('status'=>403));
    }
    $program = $programs[0];
    // Bestem sakstype (bug vs feature)
    $type = strtolower($type);
    $term = null;
    if ($type == 'bug' || $type == __('bug','skybug')) {
        $term = 'bug';
    } elseif ($type == 'feature' || $type == __('funksjon','skybug')) {
        $term = 'feature';
    } else {
        // Hvis ukjent type, defaulter vi til feature
        $term = 'feature';
    }
    // Opprett ny sak (custom post) 
    $new_post = array(
        'post_title'   => sanitize_text_field($title),
        'post_content' => wp_kses_post($description),
        'post_type'    => 'skybug_issue',
        'post_status'  => 'publish',
        'post_author'  => 1  // sett admin som forfatter, evt. egen user for API
    );
    $post_id = wp_insert_post($new_post);
    if (is_wp_error($post_id)) {
        return new WP_Error('insert_failed', __('Kunne ikke opprette sak','skybug'), array('status'=>500));
    }
    // Knytt til program via meta
    update_post_meta($post_id, '_skybug_program_id', $program->ID);
    // Sett taksonomi (type)
    wp_set_object_terms($post_id, $term, 'skybug_type');
    // Returner OK-respons med sakens ID og URL
    $response_data = array(
        'status' => 'success',
        'issue_id' => $post_id,
        'issue_url' => admin_url('post.php?post='.$post_id.'&action=edit')
    );
    return rest_ensure_response($response_data);
}
# slutt ddccbbaa
Forklaring: Vi sjekker etter obligatoriske felt og returnerer WP_Error med passende melding om noe mangler (HTTP 400). Deretter s√∏ker vi i Program-postene etter en som har meta _skybug_api_key lik den innsendte n√∏kkelen. (Vi saniterer n√∏kkelen f√∏r sammenligning). Hvis ingen treff, returner 403 feil. Hvis treff, tar f√∏rste (b√∏r egentlig bare v√¶re √©n siden n√∏klene er unike).
Avgj√∏r type: vi st√∏tter at klienten sender "bug" eller "feature" eventuelt p√• norsk (‚Äúfeil‚Äù/‚Äúfunksjon‚Äù) ‚Äì for √• v√¶re robust oversettes vi ikke alt her; enklest er √• forvente engelsk kodeord, men vi gj√∏r en enkel sjekk. (Vi legger merke til at i oversettelsessammenheng burde API-forventninger dokumenteres ‚Äì det kan vi skrive i brukermanual eller dev docs at type m√• v√¶re "bug" eller "feature").
Opprett ny sak via wp_insert_post. Vi setter post_author = 1 (admin). Et alternativ er √• opprette en dedikert ‚ÄúSkyBug API User‚Äù for slike innsendelser. Men for n√•, admin som owner.
Knytt programmet: vi lagrer program-ID i meta _skybug_program_id.
Sett taksonomi: bruker wp_set_object_terms for √• sette f.eks. 'bug' term p√• 'skybug_type' taksonomien.
Hvis alt vel, returner en JSON respons med success, og inkluderer ny sak ID og en lenke (admin URL til saken, for bekreftelse). Vi m√• registrere denne funksjonen i funksjonslogg med dens logikk, avhengigheter (f.eks. avhengig av CPT definert, meta etc.), og en merknad: ‚ÄúHvis datamodell for program eller sak endres, m√• denne funksjonen oppdateres. Ved endring av API-n√∏kkel logikk m√• autorisering justeres.‚Äù.
Sikkerhet vurdering: Vi har n√• en √•pen REST endpoint som autentiserer via en n√∏kkel. Vi b√∏r s√∏rge for at:
API-n√∏klene er hemmelige (vi har gjort det, 32 char random).
Kommunikasjon helst skjer over HTTPS (dette er p√• brukeren/serverens oppsett, men vi b√∏r anbefale det).
Vi begrenser mulige misbruk: Forel√∏pig kan hvem som helst med n√∏kkelen poste. Det er hensikten. Vi kan rate-limitere hvis √∏nskelig, men ikke kritisk i denne plan.
Vi b√∏r kanskje maskere litt responsen: Vi gir ut admin_url til saken. Det er praktisk for en admin integrasjon, men en ekstern program trenger kanskje ikke admin-lenken. Kanskje bedre √• gi en view URL (hvis vi lager front-end visning per sak). Forel√∏pig lar vi det, men noter i usikkert.json at admin_url i respons er potensielt sensitiv (kun virker for logget inn admin uansett).
Dokumentasjon til utviklere: Vi b√∏r oppdatere brukermanualen eller skrive en egen seksjon (kanskje under "Brukermanual" eller i en README for devs) om hvordan API-et brukes. Siden brukermanualen er myntet p√• admin-brukere, kan vi heller i "Brukermanual" nevne at ‚ÄúAPI integrasjon: N√•r du registrerer et program, genereres en API-n√∏kkel. Utviklere av programmet kan bruke denne n√∏kkelen for √• sende bugrapporter via en HTTP POST til nettstedet ditt. Se utviklerdokumentasjonen for detaljer.‚Äù Hvis vi har en "Diverse" seksjon, kunne den inneholdt "Utviklerinfo" med endpoint forklaring.
For √• holde oss til scope, kan vi legge litt i brukermanual n√•:
Legge til et avsnitt:
<h2>API-integrasjon</h2>
<p>Hvert program f√•r en unik API-n√∏kkel. Utviklere kan sende en HTTP POST foresp√∏rsel til <code>/wp-json/skybug/v1/report</code> for √• registrere en ny sak. Inkluder feltene <code>api_key</code>, <code>title</code>, <code>description</code>, <code>type</code> i JSON-body. Hvis n√∏kkelen er gyldig, opprettes saken automatisk i SkyBug.</p>
Dette gir i det minste en pekepinn i UI.
Vi kan ogs√• vise API-endpoint i metaboksen for Program: f.eks. under API-n√∏kkel skrive: ‚ÄúEndpoint: POST $site_url/wp-json/skybug/v1/report‚Äù. Det kan v√¶re lurt s√• admin kan kopiere det til sine utviklere. La oss forbedre skybug_render_program_api_metabox: hvis $api_key finnes, under n√∏kkelen legg:
$endpoint = home_url('/wp-json/skybug/v1/report');
echo '<p>' . __('Endpoint for bug-API:','skybug') . ' <code>' . esc_url($endpoint) . '</code></p>';
Da har de alt de trenger: URL + n√∏kkel.
Forbedre admin-lister med Program-kolonne: N√• som Program->Sak relasjon er etablert via meta _skybug_program_id, la oss gj√∏re admin-opplevelsen bedre:
Legg til filter for kolonner i sak-listen (edit.php?post_type=skybug_issue).
add_filter('manage_skybug_issue_posts_columns', function($columns){
    $columns['skybug_program'] = __('Program','skybug');
    $columns['skybug_type'] = __('Type','skybug');
    return $columns;
});
add_action('manage_skybug_issue_posts_custom_column', function($column, $post_id){
    if($column == 'skybug_program') {
        $prog_id = get_post_meta($post_id, '_skybug_program_id', true);
        if ($prog_id) {
            $prog_post = get_post($prog_id);
            if ($prog_post) echo esc_html($prog_post->post_title);
            else echo '<em>' . __('(Program slettet)','skybug') . '</em>';
        } else {
            echo '<em>' . __('(Ingen program)','skybug') . '</em>';
        }
    }
    if($column == 'skybug_type') {
        $terms = wp_get_post_terms($post_id, 'skybug_type');
        if(!empty($terms)) {
            echo esc_html($terms[0]->name);
        } else {
            echo '-';
        }
    }
}, 10, 2);
Dette legger til to kolonner: Program og Type p√• sak-oversikten. Implementasjonen viser programnavnet (eller tomt hvis ikke angitt) og type (Bug/Funksjons√∏nske). Dette gj√∏r at selv p√• standard ‚ÄúSaker‚Äù siden har admin oversikt uten √• klikke inn p√• hver sak.
I samme √•nd kan vi legge til kolonner p√• ‚ÄúProgrammer‚Äù listen for oversikt:
add_filter('manage_skybug_program_posts_columns', function($columns){
    $columns['skybug_key'] = __('API-n√∏kkel','skybug');
    $columns['skybug_webhook'] = __('Webhook','skybug');
    return $columns;
});
add_action('manage_skybug_program_posts_custom_column', function($column,$post_id){
    if($column == 'skybug_key') {
        $key = get_post_meta($post_id, '_skybug_api_key', true);
        if($key) echo '<code>' . esc_html(substr($key,0,8)) . '...</code>';  // vis f√∏rste 8 tegn for sikkerhets skyld
        else echo '<em>' . __('(Ingen n√∏kkel)','skybug') . '</em>';
    }
    if($column == 'skybug_webhook') {
        $url = get_post_meta($post_id, '_skybug_webhook_url', true);
        if($url) {
            echo '<a href="' . esc_url($url) . '" target="_blank">Webhook</a>';
        } else {
            echo '<span style="color:#aaa;">-</span>';
        }
    }
},10,2);
Dette viser i programlisten en kolonne med API-n√∏kkel (forkortet for ikke √• eksponere hele n√∏kkelen p√• skjerm un√∏dig, men lar admin se starten for identifikasjon) og en kolonne med Webhook (som en klikkbar lenke hvis finnes). Dette gir admin rask oversikt uten √• √•pne hver program.
Test funksjonaliteten fra admin-siden:
Legg til et nytt Program, f.eks. ‚ÄúSuperApp‚Äù. Lagre. Etter lagring:
Programmet skal dukke opp i listen med (Ingen n√∏kkel) under API-n√∏kkel kolonnen f√∏r refresh. Etter refresh eller √• gjen√•pne, der vil det n√• st√• en n√∏kkel (de f√∏rste 8 tegn...).
G√• inn p√• rediger ‚ÄúSuperApp‚Äù: der skal metaboksen vise API-n√∏kkelen og endpoint, og webhook-feltet tomt.
Sett en webhook URL, f.eks. https://requestbin.io/12345 (et test-endpoint). Lagre oppdatering. Sjekk at webhook kolonnen i liste n√• viser ‚ÄúWebhook‚Äù link.
Test REST API:
Bruk f.eks. en verkt√∏y (curl, REST Client) og send en POST til site.test/wp-json/skybug/v1/report med JSON:
{
  "api_key": "<API-n√∏kkelen for SuperApp>",
  "title": "Test Bug via API",
  "description": "Denne bugen kom fra programmet via API.",
  "type": "bug"
}
Forventet respons: status: success, issue_id: X, issue_url: .... Sjekk at HTTP-status er 200.
G√• til WordPress admin ‚ÄúBug Reports‚Äù siden: Der skal n√• ‚ÄúTest Bug via API‚Äù dukke opp. Program-kolonnen skal vise ‚ÄúSuperApp‚Äù for den (fordi _skybug_program_id ble satt). Type kolonne ‚ÄúBug‚Äù.
√Öpne saken via admin (klikk p√• tittel eller via Saker-listen). Sjekk at innholdet er riktig beskrivelse, at Sakstype taksonomien er satt til ‚ÄúBug‚Äù, at Program meta er satt (vi burde kanskje vise program i redigeringssiden ogs√• for saken ‚Äì dvs. en meta-boks for program tilknytning. Vi kan legge til det n√•: En dropdown i sak-redigering for √• velge program). Ekstra: For at admin skal kunne manuelt koble/endre program p√• en sak eller opprette en sak fra admin og knytte til program, vi b√∏r lage en meta-boks p√• Sak-redigeringsskjermen ogs√•:
Legg til meta box for skybug_issue post type:
add_meta_box('skybug_issue_program_box', __('Program','skybug'), 'skybug_render_issue_program_metabox', 'skybug_issue', 'side', 'default');
function skybug_render_issue_program_metabox($post) {
    $current = get_post_meta($post->ID, '_skybug_program_id', true);
    $programs = get_posts(array('post_type'=>'skybug_program','numberposts'=>-1));
    echo '<select name="skybug_program_field">';
    echo '<option value="">(Ingen program)</option>';
    foreach($programs as $prog) {
       printf('<option value="%d" %s>%s</option>', 
              $prog->ID, selected($current, $prog->ID, false), esc_html($prog->post_title));
    }
    echo '</select>';
    wp_nonce_field('skybug_issue_program_nonce','skybug_issue_program_nonce');
}
add_action('save_post_skybug_issue', function($post_id){
    if(!isset($_POST['skybug_issue_program_nonce']) || 
       !wp_verify_nonce($_POST['skybug_issue_program_nonce'],'skybug_issue_program_nonce')) return;
    if(isset($_POST['skybug_program_field'])) {
        $prog = intval($_POST['skybug_program_field']);
        if($prog) update_post_meta($post_id, '_skybug_program_id', $prog);
        else delete_post_meta($post_id, '_skybug_program_id');
    }
});
N√• har vi gitt admin mulighet til √• velge program fra en dropdown i hver sak. Dette er viktig for full funksjonalitet ‚Äì ellers kunne admin kun sette program ved √• g√• via API eller kode.
(Denne biten burde kanskje v√¶rt med i fase 1, men vi tar det her n√•r vi jobber med program-sak integrasjon.)
Test: G√• p√• en sak (f.eks. den vi opprettet manuelt i fase 1 som ikke hadde program). N√• skal side-metaboksen vise en dropdown med ‚ÄúSuperApp‚Äù valget. Velg program og lagre, se at meta ble satt og kolonnen oppdatert.
Test Webhook funksjon (hvis ikke n√•, s√• planlegges): Vi har ikke implementert det enn√•, men vi kan notere at i senere fase skal pluginen sende ut melding til det URL n√•r f.eks. en bug markeres som l√∏st. Dette kan vi gj√∏re i fase 4 n√•r vi legger til statusendring. For n√•, bare sjekk at webhook felt lagrer riktig.
Oppdater dokumentasjon (Brukermanual):
Legg inn beskrivelse under ‚ÄúProgrammer‚Äù at n√•r du oppretter et program, genereres en API-n√∏kkel automatisk ved lagring. Nevn at denne n√∏kkelen kan brukes for integrasjon.
Under ‚ÄúSaker‚Äù, si at saker kan opprettes manuelt via WP-admin, eller automatisk via API dersom programmene rapporterer inn.
Under ‚ÄúInnstillinger‚Äù ‚Äì vi har fortsatt ingen reelle innstillinger; men vi kan begynne √• tenke p√• noe: En mulig innstilling kan v√¶re et globalt API Master Key eller toggling av API. Noen admins vil kanskje skru av API-funksjonen midlertidig. Vi kan lage en innstilling ‚ÄúTillat API-innsendinger‚Äù [Ja/Nei]. Default Ja. Hvis Nei, s√• vil skybug_api_report_callback nekte (returnere 503 ‚ÄúAPI disabled‚Äù). Implementering:
Legg til en option i WP options (f.eks. add_option('skybug_enable_api', '1')). I innstillinger-siden, presenter en sjekkboks ‚ÄúTillat API-rapporter fra programmer‚Äù. H√•ndter lagring via Settings API eller manuelt.
Siden dette er litt side-quest, vi kan utsette til fase 4 n√•r vi uansett flesher ut innstillinger-siden. Men la oss notere det i usikkert.json at ‚ÄúInnstilling for √• skru av/p√• API b√∏r implementeres‚Äù.
Sikre kvalitet og logging: Etter implementasjonen i fase 2, oppdater relevant JSON-logg:
Legg til funksjonene vi skrev (metabox, save_post, REST route, etc.) i funksjonslogg.json med beskrivelser.
Noter nye verifiserte ting i fungerer.json (f.eks. ‚ÄúREST API integrasjon ‚Äì mottak av bug fungerer (testet med curl).‚Äù).
Eventuelle mislykkede fors√∏k i feil.json (kanskje vi m√•tte justere noe i API-callback? Hvis alt gikk bra, kanskje ingen).
godekilder.json kan tilf√∏yes WP REST API doc kilde hvis vi slo opp (f.eks. WordPress Developer REST API register_rest_route usage).
Verifikasjon fase 2: F√∏r vi g√•r videre, kontroller n√∏ye:
At en program-post ved lagring f√•r en n√∏kkel (og ikke genererer ny hver gang).
At n√∏kkelen vises i UI kun for de med tilgang (man m√• v√¶re admin for √• se uansett).
At REST endpoint faktisk krever riktig n√∏kkel (test med feil n√∏kkel -> f√• 403, test uten n√∏kkel -> 400).
At saker opprettet via API f√•r riktig taksonomi og meta.
At ingen del av denne nye koden br√∏t noen av fase 0/1 sine krav:
Alt er fortsatt oversettbart der det skal (ja, la oss se: vi brukte __('Ingen n√∏kkel generert...'), etc. Bra).
Ingen midlertidige tekster ‚Äì alt som vises har funksjon.
Koden f√∏lger WP best practice (nonce brukt ved form lagring, check user caps, sanitized input p√• API).
Kj√∏r PHPStan og PHPCS igjen for √• se om nye funksjoner introduserte advarsler. Fiks hvis noe dukker opp (for eksempel, vi b√∏r kanskje deklarere global $wpdb hvis brukt, men vi brukte WP API hele veien).
N√•r alt ser gr√∏nt ut og vi er sikre p√• at fase 2-tillegget fungerer robust, g√•r vi videre.
Fase 3: Saksh√•ndtering og arbeidsflyt (Bugs & Features)
I fase 3 retter vi fokuset mot selve Saker-delen: vi skal forbedre funksjonalitet rundt bugrapportering og √∏nskeliste i admin, inkludert mulighet for statusoppdatering (√•pen/lukket), kategorisering/prioritet, og notifikasjoner. Her handler det om √• legge til rette for at admin (eller utviklere) kan behandle de innkommende sakene effektivt inne i SkyBug. Hovedleveranser i denne fasen:
Statusfelt for saker (Lukke bugs): Innf√∏re mulighet til √• markere en sak som ‚ÄúL√∏st‚Äù/ferdig, og filtrere slike bort fra √•pne lister.
Kommentarer/oppdateringer: S√∏rge for at diskusjonsfeltet (WP comments) fungerer slik at man kan notere fremdrift p√• saken.
E-postvarsling: Opsjon om at n√•r nye saker kommer inn via API, send en e-post til ansvarlig, og evt. n√•r en sak lukkes send e-post til innsender (her litt vanskelig siden innsender i v√•rt system bare er en API, men kanskje til en fast kontakt).
Frontend innsending (valgfritt): Vurdere om vanlige brukere skal kunne registrere saker via et skjema p√• forsiden (det ble ikke spesifikt etterspurt, men vi tenker p√• det).
Forbedre statistikk med l√∏ste vs √•pne saker.
La oss g√• stegvis:
Implementer status for saker (√Öpen/Lukket):
Vi vil at admin skal kunne markere n√•r en bug er fikset. Vi kan gj√∏re dette p√• to m√•ter:
Legge til en taksonomi skybug_status med term ‚Äú√Öpen‚Äù og ‚ÄúLukket‚Äù.
Eller bruke WordPress‚Äô innebygde post status (for eksempel definere en custom status 'closed'). WP lar oss registrere custom post statuses for v√•rt CPT. Fordelen: de kan f√• egen farge/label i admin, og man kan bruke WP UI (f.eks. en ‚ÄúPublisert‚Äù vs ‚ÄúLukket‚Äù status). Ulempen: litt mer komplisert √• registrere og tilpasse, men la oss pr√∏ve det da det er mer elegant WP-l√∏sning.
Vi registrerer en post status:
add_action('init', function(){
    register_post_status('skybug_closed', array(
        'label' => _x('L√∏st', 'post status', 'skybug'),
        'public' => false,
        'internal' => true,
        'label_count' => _n_noop('L√∏st <span class="count">(%s)</span>', 'L√∏st <span class="count">(%s)</span>', 'skybug'),
        'post_type' => array('skybug_issue')
    ));
});
Dette lager en ny status som heter ‚ÄúL√∏st‚Äù. internal=>true betyr den vises i admin men ikke p√• front. public=>false betyr ikke offentlig querybar.
For at admin skal kunne sette en sak til denne statusen, i redigeringsskjermen m√• vi legge til alternativet. Vi kan hacke litt: WP by default viser kun standard statuser i status-dropdown. Vi m√• bruke post_submitbox_misc_actions hook til √• innpasse v√•rt alternativ:
add_action('post_submitbox_misc_actions', function(){
    global $post;
    if($post->post_type == 'skybug_issue') {
        $status = $post->post_status;
        ?>
        <div class="misc-pub-section misc-pub-post-status">
          <label><?php _e('Status:', 'skybug'); ?></label>
          <span id="post-status-display">
            <?php echo ($status == 'skybug_closed' ? __('L√∏st','skybug') : __('√Öpen','skybug')); ?>
          </span>
          <?php if($status != 'skybug_closed'): ?>
            <a href="#post_status" class="edit-post-status"><?php _e('Rediger', 'skybug'); ?></a>
            <div id="post-status-select" style="display:none;">
              <input type="hidden" name="hidden_post_status" value="<?php echo esc_attr($status); ?>" />
              <select name="post_status">
                <option value="publish" <?php selected($status,'publish'); ?>><?php _e('√Öpen','skybug'); ?></option>
                <option value="skybug_closed" <?php selected($status,'skybug_closed'); ?>><?php _e('L√∏st','skybug'); ?></option>
              </select>
              <a href="#post_status" class="save-post-status button"><?php _e('OK'); ?></a>
              <a href="#post_status" class="cancel-post-status"><?php _e('Avbryt'); ?></a>
            </div>
          <?php endif; ?>
        </div>
        <?php
    }
});
Dette er litt kompleks kode for √• integrere med WP‚Äôs publish metabox UI: Den viser n√• ‚ÄúStatus: √Öpen (Rediger)‚Äù med en dropdown for √Öpen/L√∏st. Hvis allerede L√∏st, da lar vi ikke redigere (kunne la dem √•pne igjen, men for n√• behold locked).
N√•r man lagrer, WP vil ta verdien i select name="post_status" og sette den som status, s√• det funker med wp_insert_post innabords. (Trengs kanskje litt script for at ‚ÄúOK‚Äù knappen fungerer; WP har noe builtin toggling via jQuery for .misc-pub-section editing. Vi h√•per det virker fordi vi fulgte WP‚Äôs HTML pattern.) Vi b√∏r ogs√• justere sak-listene:
P√• ‚ÄúBug Reports‚Äù og ‚Äú√ònskede funksjoner‚Äù sidene v√•re, b√∏r vi utelate saker som er L√∏st, eller i det minste markere dem. Sannsynligvis vil vi bare liste √•pne bugs der, mens l√∏ste ikke vises. Vi kan filtrere i WP_Query i de callbackene: post_status'=>'publish' (som er √•pen) i sp√∏rringen. WP standard ‚Äúpublish‚Äù vil utelate v√•re closed (fordi de har egen status, som ikke er publish). S√• faktisk trengs kanskje ikke noe ‚Äì de er ikke publish, men vent, vi b√∏r definere at closed tas ut av ‚ÄúAll‚Äù.
Standard WP listing ‚ÄúAlle‚Äù viser publish + future + drafts, men custom internal status sp√∏rs. Since 'internal'=>true, I think they show up only in All? Actually, if internal, you might need to manually include them in queries. But let's not overcomplicate:
For v√•r implementering, vi kan treat 'skybug_closed' as a type of publish variant. Alternatively, not use internal and use 'exclude_from_search' etc. But anyway, our manual lists can skip them explicitly:
For bug list: add 'post_status' => array('publish') in WP_Query to exclude closed (or array('publish','skybug_closed') if we want include).
But requirement likely to exclude solved from main bug list.
So do 'post_status'=>'publish' in skybug_render_bugs_page and features page queries so that solved ones disappear from those lists (making them effectively lists of open issues).
Vi can add another menu or filter for closed if desired, but possibly not needed.
In WP ‚ÄúSaker‚Äù listing (edit.php?post_type=skybug_issue), solved items might either appear with a status label "L√∏st" if WP knows to label them. To ensure clarity, maybe add filter to highlight closed:
We can style closed row differently via CSS or indicate in Title column. But WP automatically italicizes drafts etc. For custom, maybe not automatically. We could use post_class filter to add class if closed to the row. But maybe skip.
It's okay if admin uses our stats page or filter to see closed count.
Kommentarer og samarbeid: Siden supports=>comments er aktivert p√• sakene, WordPress tilrettelegger for kommentarer. Vi skal bruke dette som en enkel m√•te √• legge inn notater (f.eks. en utvikler kan skrive ‚ÄúFikset i versjon X‚Äù).
S√∏rg for at kommentarer er √•pne som default n√•r vi oppretter via API. V√•r wp_insert_post ikke satte 'comment_status', s√• WP vil bruke default fra CPT registration (som i CPT default er closed? Actually, by default CPT inherits global default comment setting. We might need to enforce open).
Let's explicitly set 'comment_status' => 'open' in insert post for API. And if admin adds a new manually via UI, they can tick "Allow comments" in Discussion metabox. We ensure that meta.
So in register_post_type('skybug_issue'), include 'supports'=>array('title','editor','comments') which should auto add comment support.
Possibly default comment status is closed for new CPT posts, to be safe, do:
add_action('draft_to_publish', function($post){
   if($post->post_type=='skybug_issue' && $post->comment_status!='open') {
       wp_update_post(array('ID'=>$post->ID,'comment_status'=>'open'));
   }
});
but maybe overkill. We'll trust admin to open or our API sets it open.
Test: G√• inn p√• en sak, se at det er en ‚ÄúKommentarer‚Äù seksjon under innhold. Legg til en testkommentar. Sjekk at det lagres og vises. Alt ok.
E-postvarsling: Vi √∏nsker at n√•r en ny sak kommer inn (spesielt via API), skal pluginen kunne varsle noen slik at buggen blir sett p√•. Samme ved l√∏sing (kanskje varsle den som meldte bug, men i v√•rt tilfelle vet vi ikke direkte avsender ‚Äì kunne v√¶rt program, men programmet har ikke e-post).
Vi kan i innstillinger la admin sette en e-post som skal motta varsel for nye saker. For eksempel, en tekstboks ‚ÄúVarslings-e-post for nye saker‚Äù.
La oss n√• implementere minimal e-post: N√•r skybug_api_report_callback oppretter en ny sak, etter wp_insert_post, vi kaller wp_mail() til admin_email (WordPress‚Äô admin email as fallback) eller en epost definert i options.
Example:
$admin_email = get_option('skybug_notify_email');
if(empty($admin_email)) $admin_email = get_option('admin_email');
$subject = '[SkyBug] Ny sak: ' . $title;
$message = "Det ble opprettet en ny sak via API for program \"{$program->post_title}\":\n\n" .
           "Tittel: {$title}\nType: " . ($term=='bug'?'Bug':'√ònsket funksjon') . "\n\n" .
           "Beskrivelse:\n{$description}\n\n" .
           "Se " . admin_url("post.php?post=$post_id&action=edit") . " for mer info.";
wp_mail($admin_email, $subject, $message);
(Man kan bruke HTML mail og templates, men plain tekst er ok.)
Legg config for skybug_notify_email p√• Innstillinger-siden:
I skybug_render_settings_page(), bytt ut ‚ÄúIngen innstillinger‚Äù med et skjema:
if(isset($_POST['skybug_save_settings'])) {
    check_admin_referer('skybug_settings');
    $email = sanitize_text_field($_POST['notify_email']);
    update_option('skybug_notify_email', $email);
    echo '<div class="updated notice"><p>' . __('Innstillinger lagret.', 'skybug') . '</p></div>';
}
$current_email = get_option('skybug_notify_email', get_option('admin_email'));
echo '<form method="post"><h2>'.__('Innstillinger','skybug').'</h2>';
wp_nonce_field('skybug_settings');
echo '<p><label>' . __('E-post for varsel om nye saker:', 'skybug') . '</label><br/>';
echo '<input type="email" name="notify_email" value="'. esc_attr($current_email) . '" size="40"/></p>';
echo '<p><label><input type="checkbox" name="api_enabled" value="1" ' . checked(1, get_option('skybug_enable_api',1), false) . '/> ' . __('Tillat API-innsending av saker', 'skybug') . '</label></p>';
echo '<p><input type="submit" name="skybug_save_settings" class="button button-primary" value="'.__('Lagre endringer','skybug').'"></p>';
echo '</form>';
Her har vi ogs√• lagt inn en sjekkboks for api_enabled. Vi m√• definere skybug_enable_api default 1 on plugin activation or fallback to 1 if not set. Og i skybug_api_report_callback, tidlig:
if(!get_option('skybug_enable_api',1)) {
    return new WP_Error('api_disabled', __('API-tilgang er deaktivert','skybug'), array('status'=>503));
}
S√• admin kan skru av API hvis n√∏dvendig (f.eks. i n√∏dstilfelle).
Dette dekker e-post og en innstilling for det. Test: sett notify_email til din email, gj√∏r en API call -> se at mail kommer (for test kan bruke WP Mail SMTP plugin eller log).
Varsling ved lukking av en sak:
Hvis vi skal varsle programutvikler (ekstern) at en bug er l√∏st, kunne vi bruke webhook:
Vi har webhook URL per program. Vi kan implementere at n√•r en sak endres status til lukket, pluginen sender en POST til programmets webhook (if not empty):
Hook: transition_post_status action n√•r et innlegg endrer status.
I callback, sjekk at $new_status == 'skybug_closed' og $post->post_type == 'skybug_issue'.
Hent program via meta, finn webhook URL fra programmet.
Send en HTTP POST (use WP_Http or wp_remote_post) til URL med en liten payload: e.g. JSON {"event":"issue_closed","program":"X","issue_title":"...","issue_id":ID,"url":...}.
Ingen autentisering som default (webhook URL ofte inneholder en secret or is a secret itself).
For logg: logg suksess eller feil? Vi kan kanskje logge til feil.json hvis webhook feiler? Eller bare admin notice.
Implementasjon:
add_action('transition_post_status','skybug_notify_webhook_on_close',10,3);
function skybug_notify_webhook_on_close($new_status,$old_status,$post) {
    if($post->post_type=='skybug_issue' && $new_status=='skybug_closed' && $old_status != 'skybug_closed') {
        $prog_id = get_post_meta($post->ID, '_skybug_program_id', true);
        if($prog_id) {
            $url = get_post_meta($prog_id, '_skybug_webhook_url', true);
            if($url) {
                $body = json_encode(array(
                    'event' => 'issue_closed',
                    'program' => get_the_title($prog_id),
                    'issue_title' => $post->post_title,
                    'issue_type' => (wp_get_post_terms($post->ID,'skybug_type')[0]->slug ?? ''),
                    'issue_id' => $post->ID,
                    'issue_url' => admin_url('post.php?post='.$post->ID.'&action=edit')
                ));
                $response = wp_remote_post($url, array(
                    'headers' => array('Content-Type'=>'application/json'),
                    'body' => $body,
                    'timeout' => 5
                ));
                if(is_wp_error($response)) {
                    // Log to usikkert.json eller system log
                    error_log('SkyBug webhook feilet: '.$response->get_error_message());
                }
            }
        }
    }
}
Test: Sett en webhook URL til en test endpoint (e.g. use webhook.site). Mark a bug as closed in admin, check that a request is received with correct payload.
Vi holder dette internt, kanskje ikke eksponerer i UI annet enn at admin vet at de satt en webhook.
Forbedre statistikk-siden: N√• som vi har mer data, gj√∏r statistikk-siden mer informativ:
Vis f.eks. ‚Äú√Öpne bugs vs L√∏ste bugs‚Äù, ‚Äú√Öpne features vs implementerte features‚Äù.
Ideelt med diagram: Vi kan integrere Chart.js:
Legg Chart.js (v3) file til assets/js/chart.min.js, enqueue den p√• stats page (if(current screen is skybug_stats)).
I skybug_render_stats_page(), legg et <canvas id="bugChart" width="400" height="300"></canvas> og en <script>new Chart(...)</script> med data.
Data:
For eksempel, en pie chart: slice1 = antall √•pne saker, slice2 = antall lukkede saker. Eller en bar chart med bug vs features vs closed vs open.
For simplicty: En doughnut chart: ‚ÄúFordeling av saker‚Äù med 4 segmenter: √Öpne bugs, L√∏ste bugs, √Öpne features, Implementerte (l√∏ste) features (hvis vi definerer at feature ‚Äúl√∏st‚Äù betyr implementert, vi bruker samme status).
Vi kan telle:
$all_bugs = get_posts(array('post_type'=>'skybug_issue','numberposts'=>-1,'tax_query'=>array(array('taxonomy'=>'skybug_type','field'=>'slug','terms'=>'bug'))));
$open_bugs = array_filter($all_bugs, fn($p)=>$p->post_status=='publish');
$closed_bugs = array_filter($all_bugs, fn($p)=>$p->post_status=='skybug_closed');
$all_feats = get_posts(array('post_type'=>'skybug_issue','numberposts'=>-1,'tax_query'=>array(array('taxonomy'=>'skybug_type','field'=>'slug','terms'=>'feature'))));
$open_feats = array_filter($all_feats, fn($p)=>$p->post_status=='publish');
$closed_feats = array_filter($all_feats, fn($p)=>$p->post_status=='skybug_closed');
Then pass counts to JS in a script:
const data = {
  labels: ['√Öpne bugs','L√∏ste bugs','√Öpne √∏nsker','Implementerte √∏nsker'],
  datasets: [{ data: [<?php echo count($open_bugs) ?>, <?php echo count($closed_bugs) ?>, <?php echo count($open_feats) ?>, <?php echo count($closed_feats) ?>],
               backgroundColor: ['#dc322f','#859900','#268bd2','#b58900'] }]
};
new Chart(document.getElementById('bugChart'), { type: 'doughnut', data: data });
Colors chosen just to differentiate (some Solarized palette).
Additionally, show textual stats:
"√Öpne bug-saker: X<br>L√∏ste bug-saker: Y<br>√Öpne funksjons√∏nsker: M<br>Implementerte funksjoner: N"
etc.
N√• har vi en fin statistikk-side. Test med data: lag f.eks. 2 bugs (1 open, 1 closed), 1 feature (open). Check chart shows proportions.
Frontend brukerside (/bugs): Vi skal lage en offentlig oversikt under f.eks. smartesider.no/bugs som viser ‚ÄúProgrammer / kjente Bugs | √∏nsker‚Äù i f√∏lge brukers krav. Dette gj√∏r vi n√•.
Vi velger √• implementere det via en shortcode [skybug_dashboard] som genererer HTML som kan st√• p√• en vanlig side.
Kall add_shortcode('skybug-dashboard', 'skybug_frontend_dashboard');
# eeff0011 - Shortcode callback: SkyBug frontend dashboard - se AI-learned/funksjonslogg.json
function skybug_frontend_dashboard() {
    $programs = get_posts(array('post_type'=>'skybug_program','numberposts'=>-1,'orderby'=>'title','order'=>'ASC'));
    if(empty($programs)) {
        return "<p>" . __('Ingen programmer er registrert enda.','skybug') . "</p>";
    }
    $output = "<div class='skybug-dashboard'>";
    foreach($programs as $prog) {
        $output .= "<h2>" . esc_html($prog->post_title) . "</h2>";
        // fetch open issues for this program
        $issues = get_posts(array(
            'post_type' => 'skybug_issue',
            'numberposts' => -1,
            'meta_query' => array(array('key'=>'_skybug_program_id','value'=>$prog->ID)),
            'post_status' => 'publish'
        ));
        $bugs = array_filter($issues, function($i){
            $t = wp_get_post_terms($i->ID, 'skybug_type');
            return !empty($t) && $t[0]->slug=='bug';
        });
        $features = array_filter($issues, function($i){
            $t = wp_get_post_terms($i->ID, 'skybug_type');
            return !empty($t) && $t[0]->slug=='feature';
        });
        if(empty($bugs) && empty($features)) {
            $output .= "<p><em>" . __('Ingen kjente feil eller foresl√•tte forbedringer.','skybug') . "</em></p>";
        } else {
            if(!empty($bugs)) {
                $output .= "<strong>" . __('Kjente feil:','skybug') . "</strong><ul>";
                foreach($bugs as $bug) {
                    $output .= "<li>" . esc_html($bug->post_title);
                    // optionally indicate if solved:
                    // but we only included open issues (publish) so skip solved entirely.
                    $output .= "</li>";
                }
                $output .= "</ul>";
            }
            if(!empty($features)) {
                $output .= "<strong>" . __('√ònskede funksjoner:','skybug') . "</strong><ul>";
                foreach($features as $feat) {
                    $output .= "<li>" . esc_html($feat->post_title) . "</li>";
                }
                $output .= "</ul>";
            }
        }
    }
    $output .= "</div>";
    return $output;
}
# slutt eeff0011
Dette loop-er gjennom programmer, lister under hvert: ‚ÄúKjente feil:‚Äù liste og ‚Äú√ònskede funksjoner:‚Äù liste, basert p√• saker med status √•pen. Hvis ingen saker for det programmet: viser "Ingen kjente feil..." meldingen.
(Alle strenger oversettes. Vi utelater l√∏ste bugs fra listen ‚Äì kun √•pne kjente problemer vises offentlig.)
Dette shortcode m√• s√• settes inn p√• en side med slug ‚Äúbugs‚Äù. Vi kan informere admin: I brukermanual kan vi skrive ‚ÄúFor √• vise en publik oversikt over kjente feil, opprett en side og legg inn shortcode [skybug-dashboard].‚Äù Evt. kunne plugin autogenerert siden ved aktivering, men det er litt p√•trengende. Vi velger dokumentere og la admin gj√∏re det.
Siden skal v√¶re offentlig. Hvis siden er public, alle ser (kun oversikt, ikke detaljer). Vi viser bare titler. Hvis man vil ha detaljer, m√• man kontakte support; plugin gir ikke komplette bug beskrivelser offentlig, noe som kanskje er riktig av hensyn til sensitiv info. (Vi kan notere at dersom man √∏nsker offentlige bug-sider kan man gj√∏re CPT 'public' og designere template, men det er en annen dimensjon.)
Test: Lag et par saker under SuperApp (via admin or api), one bug "App crashes on start", one feature "Add dark mode". Then create a WP Page "Bugs", put [skybug-dashboard] in content. View that page in front-end (while logged out even): It should list "SuperApp", then under it "Kjente feil: App crashes on start", "√ònskede funksjoner: Add dark mode". Yes.
Oppdatere Diverse-siden: Vi tenkte at "Diverse" kunne vise interne logger. La oss realisere det:
I skybug_render_misc_page(), vi kan lage faner (ul li nav) med "L√¶ringslogg", "Gode kilder" etc., eller enklest: bare dump innholdet av JSON-filene:
function skybug_render_misc_page() {
  echo '<div class="wrap"><h1>Diverse / Dev-info</h1>';
  $funksjonslogg = json_decode(file_get_contents(SKYBUG_DIR . 'AI-learned/funksjonslogg.json'), true);
  if($funksjonslogg) {
      echo '<h2>Funksjonslogg</h2><ul>';
      foreach($funksjonslogg as $entry) {
         echo '<li><strong>' . esc_html($entry['id']) . '</strong> - ' . esc_html($entry['navn']) . ': ' . esc_html($entry['beskrivelse']) . '</li>';
      }
      echo '</ul>';
  }
  // Similarly for fungerer.json etc.
  echo '</div>';
}
Formatere litt bedre kanskje, men ideen: admin kan se hvilke funksjoner som finnes og hva de gj√∏r (trekke ut info fra JSON loggene). Dette er prim√¶rt for utviklerens nytte og er litt uvant i en plugin, men siden det ble √∏nsket, implementerer vi det. Pass p√• at JSON-filer faktisk har gyldig JSON; alternativt, hvis vi logget dem som tekst-linjer, m√• tilpasse. Vi antar de er JSON arrays.
Oppdatere brukerh√•ndboken: N√• som funksjonalitet er tiln√¶rmet komplett, oppdater manualen:
Beskriv hvordan man lukker en sak: rediger sak, endre status til L√∏st, trykk Oppdater.
Nevn at lukking utl√∏ser at programutviklere kan f√• varsel via webhook (hvis satt).
Beskriv at man kan kommentere p√• en sak for oppf√∏lging.
Forklar epostvarsel: Under Innstillinger kan du sette epost som f√•r varsel ved nye saker.
Forklar front-end: at [skybug-dashboard] kan brukes for √• vise kundene dine en oversikt over kjente feil/√∏nsker per program (dette kan v√¶re nyttig for transparens).
Alt p√• norsk.
Test scenario helhetlig:
Simuler hele workflow:
Admin legger til program "AppX". Utviklerne av AppX f√•r API-n√∏kkel. De integrerer i appen.
En feil oppst√•r i AppX, appen sender POST med key, title, desc. Sak dukker opp i SkyBug -> admin f√•r epost "Ny sak: ..." -> admin ser i "Bug Reports".
*Admin unders√∏ker, kommenterer under saken "Reprodusert, ser p√• det".
Utvikler fikser feilen, admin setter status L√∏st, trykker Oppdater. Da sender plugin webhook til AppX‚Äôs URL (f.eks. deres system kan logge at bug er l√∏st).
*Webhook feiler? Plugin logger det i error_log, admin ser evt. ikke direkte. (Man kunne vist en admin_notice "Webhook sending feilet" men det er litt for dev, lar v√¶re).
*Den l√∏ste saken forsvinner fra Bug Reports-lista (fordi n√• status=skybug_closed, som vi ikke tar med).
*Statistikk-siden viser 1 l√∏st bug.
*Frontend side "Bugs" oppdateres automatisk: bug er borte fra "kjente feil" list for AppX (for den er l√∏st).
Sjekk at ingen rugefeil i dataflyten.
Prestasjon: med mange program/saker, det meste er fine da vi brukte get_posts with numberposts=-1 in some places; i real large usage, kanskje burde gjort pagination. Not an immediate concern, assume manageable.
Kvalitetssikring fase 3:
Kj√∏r gjennom PHPCS/Stan igjen. Sjekk at nye epostfunksjoner, REST etc er OK. (M√• kanskje stubbe Chart.js not causing any WP coding standard flags.)
S√∏rg for at alt vi viser fortsatt er oversatt. Vi la til en del strenger, men vi passet p√• __('','skybug').
Logging: funksjonslogg og √∏vrige JSONer oppdateres med eventuelle nye funksjoner (f.eks. skybug_notify_webhook_on_close, skybug_frontend_dashboard, etc.).
Verifiser at fase 0-2 regler fortsatt holdes: ingen fake data (vi genererte alt ekte), best practices (nonce, permission checks).
At dette punktet har pluginen ganske mye funksjonalitet. S√∏rg for at alt som er bygget tidligere (f.eks. Phase 2's API) fortsatt funker etter Phase 3 additions (test API again, etc., yes should).
N√•r alt er testet og godkjent, g√•r vi videre.
Fase 4: Avrunding ‚Äì Finish og Polering
Fase 4 handler om √• ferdigstille pluginen, gj√∏re opprydding, optimalisering og dokumentasjon klar. Her fokuserer vi ogs√• p√• eventuelle tilleggs√∏nsker og sikrer at pluginen er klar for reell produksjonsbruk. Oppgaver i fase 4 inkluderer:
Kodepolering og optimalisering:
G√• gjennom hele kodebasen for √• refaktorere duplisert logikk og sikre konsistens. For eksempel, vi har lignende kode for listing bugs/features i admin og front-end ‚Äì vurd√©r √• trekke ut felles funksjon hvis det rydder opp. (Men ikke p√• bekostning av klarhet.)
Optimaliser sp√∏rringer: I front-end shortcoden henter vi alle saker per program i l√∏kker. For mange programmer kan det bli ineffektivt. Vi kunne omarrangere til √• hente alle √•pne saker en gang og deretter sortere dem per program i PHP. Hvis skal skalere, implementer:
$open_issues = get_posts(array('post_type'=>'skybug_issue','numberposts'=>-1,'post_status'=>'publish'));
// Deretter group by program meta in loop
Derimot, for moderate bruk, dagens l√∏sning er ok.
Vi kan nevne i usikkert.json at for >1000 saker, vurdere optimalisering.
Sjekk at vi ikke har noen debug-kode eller var_dump etc. (Nei, alt rent.)
Sjekk at plugin avaktivering/sletting ryddes (om √∏nsket): Vi kan tilby en avinstalleringsrutine (uninstall.php) som fjerner custom options (skybug_enable_api, skybug_notify_email) og eventuelt CPT innhold? Som bug tracker data er verdifull, vi sletter ikke CPT innhold automatisk. Det overlates til admin.
Sett versjonsnummer i topp til 1.0.0 (eller bump til 1.0.0 etter alt testet). Oppdater readme.txt om det finnes (vi kan lage en readme for WP repo standard).
Brukerdokumentasjon ferdigstilling:
G√• over ‚ÄúBrukermanual‚Äù side i pluginen: Oppdater den for √• inkludere alt av nye funksjoner i fase 3:
Legg inn seksjon om ‚ÄúLukke saker‚Äù (hvordan markere som l√∏st).
Legg til ‚ÄúNotifikasjoner‚Äù (forklar at plugin kan sende epost til X n√•r ny sak opprettes, justerbart i innstillinger).
Legg til ‚ÄúWebhook‚Äù info: at hvis en webhook URL er satt for et program, vil det motta en JSON-varsling n√•r en sak lukkes.
Front-end oversikt: beskriv hvordan man kan opprette en offentlig side med oversikt over kjente feil: (som sagt, lage WP-side med shortcoden).
F√• med eventuell troubleshooting: f.eks. ‚ÄúHvis API-innsendinger ikke fungerer, sjekk at API er aktivert i innstillinger og at riktig n√∏kkel brukes.‚Äù
Kort sagt, s√∏rg for manualen er utt√∏mmende slik at en ny bruker av pluginen skj√∏nner hensikten med hver undermeny og funksjon.
Spr√•kvask: manualtekstene skal v√¶re tydelige og p√• godt norsk. Vari√©r setninger hvis repetisjon. (Vi har litt repetisjon i oversikter, men det er greit.)
Slutt-test i helhet:
Simuler at en kunde/annen person bruker pluginen kun via manual: F√∏lg manualens anvisninger, se at alt stemmer og er logisk.
Test access control: logg inn som en bruker uten manage_options (f.eks. forfatter) ‚Äì de skal ikke se SkyBug-menyen i det hele tatt. (Fordi vi satte manage_options som capability p√• alle menypunkter.) Bra.
Multisite scenario hvis relevant: Siden CPTer og options normalt er pr. site, det funker i hver site isolert. Ingen spesielle hensyn trengs bortsett fra at API-n√∏kler unike pr site. Ok.
Test oversettelse: generer en .pot fil av tekstene (vi kan bruke wp i18n make-pot if avail). Forsikre at text domain er konsistent ("skybug" overalt).
Test avinstallasjon (hvis vi laget uninstall rutine).
Oppdater AI-loggfiler siste gang:
Legg inn i fungerer.json at "Hele plugin gjennomg√•tt, alle funksjoner verifisert i scenarioer".
Eventuelle gjenst√•ende ting i usikkert.json som ikke ble implementert, men kanskje kan fungere: f.eks. "Mulighet for brukere √• sende inn saker via et offentlig skjema ble ikke implementert, men man kunne vurdert det via en [shortcode] form med captcha etc." ‚Äì bare for referanse.
feil.json: hvis ingen nye feil, fint, ellers notere ting man pr√∏vde men droppet (kanskje vi droppet seperate email per program eller droppet caching).
godekilder.json: legg inn eventuelle nye kilder, f.eks. link til Chart.js docs hvis vi brukte det, WP post status ref.
Konklusjon: Fasen avsluttes med at pluginen SkyBug n√• fremst√•r komplett:
Admin-meny med alle √∏nskede seksjoner (Innstillinger, Brukermanual, Programmer, Saker, Statistikk, Bug Reports, √ònskede funksjoner, Diverse) ‚Äì alle med ikoner (vi la hovedikon + planla CSS for sub-ikoner).
Full CRUD for programmer og saker, API-integrasjon, notifikasjoner og oversikter.
Koden er robust og f√∏lger WP-standarder, og AI/dokumentasjon systemet (AI-learned logs) er oppdatert for hver del, slik at videre vedlikehold blir enklere.
Til slutt, f√∏r vi erkl√¶rer oss ferdige, dobbeltsjekker vi at absolutt alle punkter fra spesifikasjonen er oppfylt:
Lagring av l√¶rdom (ja, vi har JSON-logger).
Ingen dummy-tekst (sjekket at manualens l√∏fter er oppfylt; alt som st√•r i UI finnes funksjonelt).
Fasevalidering (vi har tydelig i teksten at hver fase skal sjekkes).
Spr√•kvariasjon (vi har formulert repetisjon litt forskjellig).
Guardrails fra fase 0 (vi har fortsatt PHPCS config, ingenting ble gjort som strider mot regler).
Best practice (sikkerhet, i18n, etc) ‚Äì alt implementert i tr√•d med WP Codex.
VSCode extensions var bare i start, men h√•per de ble fulgt.
N√•r alt dette er gjennomg√•tt og godkjent, kan pluginen lanseres som en ferdig versjon 1.0. üéâ
